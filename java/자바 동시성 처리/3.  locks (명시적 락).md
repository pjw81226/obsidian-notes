기본적으로 `synchronized`가 못하는 여러 기능들을 제공한다.

- **공정성(Fairness) 설정:** 가장 오래 기다린 쓰레드에게 우선권을 줄 수 있습니다.

- **Non-blocking 시도:** 락을 얻으려고 무한정 대기하는 게 아니라 지금 락 없으면 그냥 나중에 올게(`tryLock`)가 가능하다
    
- **타임아웃:** "5초만 기다려보고 안 되면 포기할래"가 가능하다
    
- **락의 순서 자유도:** 한 메서드에서 시작해서 다른 메서드에서 락을 푸는 등 유연한 구조를 가질 수 있다.

대표 클래스

ReentrantLock (가장 기본)
- 재진입 (이미 락을 가진 쓰레드가가 같은 락을 다시 획득 하는 것)이 가능하다

ReentrantReadWriteLock (읽기/쓰기 분리)
- 읽는 건 여러 명이 동시에 해도 됨, 쓰는 건 한 명만 해야 함"라는 로직에 최적화되어 있다
- **ReadLock:** 데이터가 변하지 않는 동안은 여러 쓰레드가 동시에 접근 가능 (성능 대폭 향상)
- **WriteLock:** 한 쓰레드가 쓰는 동안에는 읽기/쓰기 모두 차단

Condition (쓰레드 간 신호 전달)
- `synchronized`의 `wait()`, `notify()`와 대응된다. 특정 조건이 만족될 때까지 쓰레드를 대기시키거나 깨울 수 있다. 하나의 락에 여러 개의 `Condition`을 생성할 수 있어 '생성자 쓰레드'와 '소비자 쓰레드'를 따로 깨우는 정교한 제어가 가능하다.



> [!주의할 점]
> 명시적 락은 개발자가 직접 해제해야하므로 예외가 발생하더라도 락이 풀리지 않도록 아래와 같은 형식을 따라야 한다. 
```java
Lock lock = new ReentrantLock();

lock.lock(); // 1. 락 획득
try {
    // 2. 임계 영역 (Critical Section)
    // 쓰레드 안전이 필요한 로직 수행
} finally {
    lock.unlock(); // 3. 반드시 락 해제! (안 하면 데드락 발생)
}
```