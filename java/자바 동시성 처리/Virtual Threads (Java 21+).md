
Go Routine 느낌..

기존의 자바 스레드는 OS가 관리하는 커널 스레드와 1:1로 매핑됨
- 메모리 비용 : 스레드 하나당 약 1MB 이상의 스택 메모리를 점유
- 생성 비용: OS 레벨에서 생성되므로 시간이 오래 걸림
- 컨텍스트 스위칭 오버헤드: OS가 수만 개의 스레드를 관리하려면 CPU가 스레드를 갈아 끼우는 데만 너무 많은 힘을 씀
- 결과적으로: 수만 명의 사용자가 동시에 접속하는 서버에서 사용자당 스레드 하나(Thread-per-request) 모델을 쓰면 서버가 금방 뻗어버림. 이를 피하려고 복잡한 비동기 프로그래밍(WebFlux 등)을 공부해야함

### 가상 스레드의 작동원리
가상 스레드는 OS 스레드와 직접 연결되지 않음. 대신, JVM이 관리하는 아주 가벼운 스레드임

- M:N 매핑 : 수백만개의 가상 스레드를 소수의 OS 스레드 위에서 실행
- Mount / Unmount : 가상 스레드가 I/O 작업 (DB 호출 등)을 만나서 기다려야 하면, 실제 OS 스레드에서 즉시 내려옴(Unmount) 그리고 다른 실행 가능한 가상 스레드가 그 자리를 차지(mount)
- 효율성 : 이 과정이 JVM 내부에서 일어나므로 OS 레벨의 context switching 보다 수백배 빠르고 메모리도 KB 단위만 사용한다.

### 개꿀인 이유
1. 웹플럭스로 비동기 서버 안만들고 전통적인 MVC 서버 만들어도 내부에서 비동기처럼 알아서 효율적으로 돌아감
2. Thread per request가 문제가 없어짐. 한 요청에 스레드 하나라는 직관적인 모델을 수백만개의 요청에도 적용할 수 있음

```java
//단순 생성
Thread vThread = Thread.ofVirtual().start(() -> {
    System.out.println("가상 스레드 실행 중!");
});

//ExecutorService와 함께 사용 (가장 권장되는 방식)
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    executor.submit(() -> {
        // DB 조회나 네트워크 호출 같은 I/O 작업 수행
        return "결과";
    });
} // close 시 자동으로 모든 작업 완료 대기
```

### 주의할 점
- 스레드 풀링 하지마라. 
	- 가상 스레드는 애초에 크기가 매우 매우 매우 작아 생성 비용이 없음. 굳이 풀을 만들어서 재사용하지말고 필요할 때마다 새로 만들어서 써라
- ThreadLocal 주의
	- 수백만개가 생길 수 있으므로 각  스레드에 너무 큰 데이터를 담으면 메모리가 부족해질 수 있음
- CPU 작업에는 부적합
	- 가상 스레드는 I/O 대기 시간에 진가를 발휘한다. 복잡한 수학연산 같은 CPU 위주의 작업은 기존의 플랫폼 스레드가 유리함.


enable 방법
```yaml
spring.threads.virtual.enabled=true
```
모든 요청 처리를 가상 스레드 방식으로 전환 가능


### 다만 모두 바꾸면 문제될 점..

1. synchronized 문제
	가상 스레드 안에서 `synchronized` 블록을 사용하고 그 안에서 I/O(DB 호출 등)가 발생하면 가상 스레드가 OS 스레드에 고정되어 버림 이 경우 가상 스레드의 장점인 "잠시 비켜주기"가 안 되어 성능이 일반 스레드보다 나빠질 수 있음
	**해결책:** `synchronized` 대신 앞서 배운 `ReentrantLock`을 사용하면 이 문제가 해결됨

2. CPU 집중작업
   복잡한 암호화 대량의 이미지 처리 같은 CPU를 100% 쓰는 작업은 가상 스레드보다 기존 플랫폼 스레드가 더 효율적. 가상 스레드는 **Blocking**이 많은 작업에 최적화되어 있기 때문

3. 풀링 금지
	기존에는 `FixedThreadPool`을 만들어 스레드를 아껴 썼지만, 가상 스레드는 쓰고 버리는 소모품. **Thread Pool을 만드는 대신 Thread per Task** 개념으로 접근해야함