락(Lock)을 걸지 않고도 동시성을 처리하는 **Non-blocking** 방식.  낙관적 락

CAS 연산은 세가지 인자 필요
- 메모리 위치 (V): 값을 읽어올 실제 변수의 주소
- 기대값 (A): 내가 알고 있는 현재 변수의 값
- 새로운 값 (B): 내가 바꾸고 싶은 새로운 값

- 메모리 위치 `V`에 저장된 현재 값이 내가 알고 있는 `A`와 **일치하는지 확인**
- 일치한다면, 다른 쓰레드가 가로채지 않았다고 판단하여 값을 `B`로 업데이트
- 일치하지 않는다면(다른 쓰레드가 값을 바꿨다면), 업데이트를 포기하고 다시 시도하거나 실패를 반환

아토믹 계열의 데이터 타입들은 실패하면 스핀락으로 재시도 


단점
- ABA 문제 : 값이 A였다가 B로 바뀌고 다시 A로 돌아왔을 때, CAS는 값이 바뀌지 않았다고 착각할 수 있다. (이를 해결하기 위해 `AtomicStampedReference` 사용)
- 무한 루프(Spin Lock): 경합이 너무 심하면 계속해서 실패하고 재시도하므로 CPU 점유율이 높아질 수 있다.


`AtomicStampedReference`
- 단순히 값만 저장하는게 아니라 버전이나 타임스탬프를 같이 저장한다.
	- **값(V):** 실제 데이터
	- **스탬프(int):** 변경될 때마다 증가시키는 버전 번호
- 가장 핵심적인 메서드는 `compareAndSet` 인자가 네개로 늘어난다.
```java
public boolean compareAndSet(
    V expectedReference, // 기대하는 참조 값
    V newReference,      // 바꿀 새로운 참조 값
    int expectedStamp,   // 기대하는 스탬프(버전)
    int newStamp         // 바꿀 새로운 스탬프(버전)
)
```
- 간단한 코드 예시
```java
// 초기값 "A", 초기 스탬프 0
AtomicStampedReference<String> asr = new AtomicStampedReference<>("A", 0);

int initialStamp = asr.getStamp(); // 현재 스탬프 획득
String initialRef = asr.getReference(); // 현재 값 획득

// 중간에 누군가 A -> B -> A로 바꿨다고 가정 (스탬프는 계속 증가함)

// 값은 "A"로 같지만, 스탬프가 initialStamp와 다르기 때문에 실패함
boolean success = asr.compareAndSet(initialRef, "NewValue", initialStamp, initialStamp + 1);

System.out.println("성공 여부: " + success); // false 출력
```
