자바에서 스레드를 직접 new Thread()로 생성하는 것은 비싼작업. 

스레드가 필요할 때마다 만들고 버리는 비효율을 해결하기 위해 스레드를 미리 만들어놓고 재사용하는 스레드풀

이를 표준화 해서 제공하는것이 **Executor Framework**

### ExecutorService
`ExecutorService`는 `Executor` 인터페이스를 확장한 인터페이스로 작업의 실행, 라이프사이클 관리, 결과 반환을 위한 기능을 제공한다.

주요 method
- `execute(Runnable)`: 반환값 없이 작업을 실행    
- `submit(Callable/Runnable)`: 작업 결과나 상태를 확인할 수 있는 `Future` 객체를 반환
- `shutdown()`: 새로운 작업은 받지 않고, 이미 제출된 작업들을 마저 실행한 뒤 종료
- `shutdownNow()`: 현재 실행 중인 작업들을 중단시키려 시도하고 즉시 종료

Executors를 이용한 스레드 풀 생성
- `Executors`라는 팩토리 클래스를 통해 다양한 형태의 스레드 풀을 쉽게 만들 수 있다
- **`newFixedThreadPool(int)`**: 고정된 개수의 스레드 풀을 생성. 가장 많이 쓰이는 방식
- **`newCachedThreadPool()`**: 필요할 때마다 스레드를 생성 작업이 끝나고 60초간 응답이 없으면 스레드를 제거 작업량이 가변적일때 유리
- **`newSingleThreadExecutor()`**: 단 하나의 스레드만 사용하여 작업을 순차적으로 처리
- **`newScheduledThreadPool(int)`**: 특정 시간 이후에 실행하거나 주기적으로 실행해야 하는 작업에 사용


코드예시
```java
public class ExecutorExample {
    public static void main(String[] args) {
        //3개의 스레드를 가진 풀 생성
        ExecutorService executor = Executors.newFixedThreadPool(3);

        //작업 제출 (Runnable)
        executor.submit(() -> {
            System.out.println(Thread.currentThread().getName() + " : 작업 중...");
        });

        //결과가 있는 작업 제출 (Callable)
        Future<Integer> future = executor.submit(() -> {
            Thread.sleep(1000);
            return 42;
        });

        try {
            //결과를 얻을 때까지 기다림 (Blocking)
            System.out.println("결과: " + future.get());
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }

        //종료
        executor.shutdown();
    }
}
```

**적절한 풀 크기:** 
- CPU 집중 작업: CPU 코어 수 + 1
- I/O 집중 작업(DB, API 호출 등): 코어 수보다 넉넉하게 설정