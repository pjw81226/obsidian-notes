> 가장 기초적인 수준에서 공유 자원을 보호하거나 메모리 일관성을 유지하는 방법

>[!메모리 가시성이란...]
>스레드가 데이터를 바꿨을 때, 다른 스레드가 그 바뀐 값을 즉시 알 수 있느냐? 를 의미

---
### Synchronized (동기화 블록/메소드)
>가장 고전적인 방식
- 특정 코드 구간이나 메서드에 한 번에 하나의 스레드만 들어갈 수 있도록 **뮤텍스(Mutex)** 락을 건다.
- 사용하기 쉽지만 잘못 사용하면 성능 저하가 심하고 **DeadLock**에 빠질 수 있다.

==성능저하== (Context Switching 오버헤드) 
- 락을 획득하지 못한 스레드는 Block 상태가 된다.
- 이후에 락이 풀려 다시 실행될 때 컨텍스트 스위칭 비용이 발생 (오버헤드)

==유연성 부족==
- 락을 얻을 때까지 무한정 기다린다. 3초만 기다려보고 안 되면 포기하는 타임아웃 설정이 불가능하다.
- 기다리는 도중 interrupt 걸어서 깨울 수도 없음

==공정성 없음==
- 락이 풀렸을 때 기다리던 스레드 중 누가 락을 가져갈지 보장하지 않는다.
- Starvation에 빠질 수 있다.

==데드락 위험==
- 일반적인 데드락에 대해 대처가 불가능하다.
1. `Thread A`가 `A`를 점유 하면서 `B`를 대기
2. 동시에 `Thread B`가 `B`를 점유 하면서 `A`를 대기

> Mutex Lock은 열쇠가 하나인 것... 세마포어는 n개 인 것....


---
### Volatile
- 변수 선언 시 사용하며, 이 변수의 값은 CPU 캐시가 아닌 **메인 메모리**에 직접 읽고 쓴다는 것을 보장한다.

**메모리 가시성이 핵심개념**

==문제상황==
1. `Thread A`가 변수 값을 바꿨는데 이 변경 사항이 `Thread A`의 CPU 캐시(`L1`, `L2`) 에만 반영되고 메인 메모리에는 아직 안 갔을 수 있다.
2. `Thread B`는 메인 메모리에 변경된 값이 없으니 계속해서 자신의 캐시에 있는 값을 읽게 된다.

> [!한가지 하드웨어적인 상식]
> `L1`, `L2` 등의 캐시는 **CPU 코어** 마다 붙어있다. 즉. `Thread A`가 첫번째 코어 `Thread B` 가 두번째 코어에서 돌아가고 있다면 서로의 `L1`, `L2` 등의 CPU 캐시를 들여다 볼 순 없다.


==Volatile의 역할==
 - 변수를 `volatile`로 선언하면 "이 변수의 모든 읽기와 쓰기는 CPU 캐시를 거치지 않고 무조건 메인 메모리에서 직접 수행해라" 라고 지시하는 것이다.
	 - 즉 한 스레드가 값을 바꾸면 다른 스레드는 즉시 그 바뀐 값을 볼 수 있게 보장한다.

==명령 재정렬 방지==
- 컴파일러나 CPU는 성능 최적화를 위해 서로 의존성이 없는 명령어의 순서를 마음대로 바꿀 수 있다. (Instruction Reordering).

==치명적인 한계==: 원자성(Atomicity)은 보장하지 않음
- `Volatile`은 최신 값 읽기만 보장하지 동시 접근 제어를 보장하지는 않는다.



>[!명령 재정렬시 무슨 문제가 발생하나?]
>

다음의 예시상황을 보자
```java
int a = 0;
boolean ready = false;

// Thread A (Writer)
void writer() {
    a = 10;         
    ready = true;   
}

// Thread B (Reader)
void reader() {
    if (ready) {    
        print(a);  
    }
}
```

A는 `a`에 데이터를 채우고 `flag`를 `true`로 바꾸는 코드
B는 `flag`를 확인하고 `a`를 출력하는 코드

컴파일러가 보기에는 A의 코드 내부 `a=10`과 `ready=true`가 연관이 없다고 인식해 둘의 순서를 바꿀 수 있다.

```java
// Thread A 
void writer() {
    ready = true;    
    // ... (잠깐의 틈) ...
    a = 10;          
}
```
컴파일러가 다음과 같이 `Thread A` 의 실행계획을 reordering 을 했다고 가정하자.

*잠깐의 틈* 에 만약 `Thread B` 가 치고 들어와서 `reader()`를 실행해버린다면... `flag`는 `true` 인데 `a`에는 값이 없는 대참사가 발생한다.



>[!다른상황]

```java
instance = new Singleton();
```

이를 기계어로 보면 세가지 step을 거친다.
1. 메모리 할당 (객체 담을 공간 확보)
2. 초기화 (생성자 실행해서 객체 내부 필드 채움)
3. 할당 (instance 변수에 1번에서 만든 주소 값 연결)

하지만 CPU는 2번과 3번의 순서를 변경할 수 있다.
1. 메모리 할당
2. instance 변수에 주소값 연결
3. 생성자 실행해서 변수 채움

위험한 시나리오
1. `Thread A`가 작업을 하다가 2번까지만 하고 잠시 멈춤
2. `Thread B`가 `if (instance != null)` 검사를 진행. `instance`에는 주소값이 있으니 통과
3. `Thread B`가 `instance`를 사용하려고 하는데 아직 초기화가 안되어있으니 `NullPointerException` 발생
