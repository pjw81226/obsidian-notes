
### Blocking Queue
개발자가 직접 스레드 동기화를 신경 쓰지 않아도 되게 해주는 큐

- 특징
	- 큐가 가득 차면 데이터를 넣으려는 스레드는 빈 공간이 생길 때 까지 자동으로 대기한다.
	- 큐가 비었다면 데이터를 꺼내려는 스레드는 데이터가 들어올 때까지 자동으로 대기한다.
- `ArrayBlockingQueue`, `LinkedBlockingQueue`

### ConcurrentHashMap
가장 대표적이고 잘 사용된다.

- **기존 문제점**
	- 옛날 방식인 `HashTable`은 데이터를 건드릴 때마다 Map 전체에 `Lock`을 건다. 따라서 한 스레드가 작업 중이면 다른 스레드들은 전부 기다려야 해서 속도가 매우 느림
- **해결방식**
	- `ConcurrentHashMap`은 맵을 여러 Segment(Bucket)으로 쪼개서 관리한다.
	- 데이터를 쓸 떄 해당 Segment만 잠그기 때문에 다른 구역에 접근하는 스레드는 기다릴 필요가 없다.
	- 읽기 작업은 아예 락을 걸지 않아 매우 빠르다.


### CopyOnWriteArrayList
쓸 때 복사하는 리스트

- 작동 방식
	- 데이터를 읽을때는 락 없이 읽음
	- 데이터를 추가하거나 삭제할 때 리스트 전체를 **새로 복사**,
	   그 새로운 복사본에 수정사항을 반영한 뒤 갈아끼운다.
- 장점
	- 읽기 작업 시에는 동기화 비용이 `0`에 가깝다.
	- 데이터가 바뀔 걱정 없이 안전하게 순회가능하다.
- 단점
	-  쓸 때마다 배열을 통째로 복사하므로 쓰기 작업이 많으면 성능이 치명적으로 떨어진다.
- 용도
	- 이벤트 리스너 목록 설정 정보 등 읽기는 엄청 많은데 수정은 거의 없는 경우.