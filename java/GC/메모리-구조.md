## Heap 메모리

> [!note] Heap 메모리
> **"GC튜닝"의 대부분은 Heap 안에서 어디가 빨리 차고, 어떤 수집이 자주 돌고, 얼마나 멈추는지를 다룸**

- 자바 객체, 배열이 실제로 저장되는 공간
- GC가 "살아있는 객체", "죽은 객체"를 판단해서 회수하는 주 대상이 Heap

![[Pasted image 20260108021804.png]]

<br>

---
## Young Generation
> Young은 "새로 만들어진 객체가 몰리는 곳

**대부분의 객체는 금방 버려진다(Generation Hypothesis)** 라는 가정 때문에 여기를 빠르게 자주 청소

### Eden
> Eden은 자주 비우는 쓰레기통 처럼 운영해서 빠르게 처리하는 구조.

- **새 객체가 처음 할당되는 공간** (거의 대부분 Eden부터 시작)
- Eden이 꽉차면 **Young GC(=Minor GC)** 가 발생하는 대표 트리거
- 흐름
	1. 객체 생성 → Eden에 쌓임
	2. Eden이 부족해짐 → Young GC 실행
	3. 살아남은 객체만 Survivor로 **"복사"** 되고 Eden은 통째로 비워짐 

### Survivor (S0, S1)
> Survivor는 "조금 더 살아남는 애들"을 걸러서 오래 사는 객체만 Old로 보내기 위한 완충지대.

- Survivor는 두칸(S0, S1)으로 운영되는 대피소 개념
- Young GC 때 살아남은 객체들이 Eden에서 **Survivor로 복사됨**
- 다음 GC 때는 역할이 바뀐다.
	- 이전에 사용한 Survivor는 From
	- 새로 복사 받을 Survivor는 To
	- 따라서 **GC마다 S0 ↔ S1 이 스왑된다.**

중요한 개념
- 객체 나이 : Young GC를 몇번 살아남았는지 카운트
- 일정 나이(tenuring threshold)에 도달하거나 Survivor가 꽉 차면 **Old로 승격 (promotion)**

<br>

---
## Old Generation
> 실무에서 "GC 때문에 서버가 멈춘다 / 느려진다" 는 이 Old 쪽 이슈인 경우가 많음

- Young에서 여러번 살아남아 장수 객체가 모이는 곳
- 여기 GC는 Young보다 덜 자주 일어나지만, 한번 일어나면 보통 더 무겁고(멈춤이 길 가능성) 크다.

**Old가 문제 되는 패턴**
- Promotion이 너무 많이 발생 →Old가 빨리 참
- Old가 부족 → **Major / Old GC 또는 Full GC** 성격의 큰 청소가 일어나면서 지연이 커질 수 있음
- 장수 객체가 많고 변하지 않음 → "치우기 어렵고 오래걸리는 방"이 됨

<br>

---
## Metaspace (Java 8+)

- Heap 이 아니라 Native Memory 쪽에 잡히는 영역
- **클래스 메타데이터(클래스 로딩 정보, 메서드 정보 등)** 가 저장됨

- 클래스가 계속 로딩만되고 언로딩이 안되면 Metaspace가 커져서 문제가 된다. (**ClassLoader 누수**)
- Metaspace 부족은 "Heap OOM"이 아니라 **Metaspace OOM** 형태로 터질 수 있음
<br>

---

## 관련 문서
- [[GC]]

