# STW

> [!note] 개념 
> **STW는 JVM이 애플리케이션 스레드(요청 처리 스레드 등)를 잠깐 멈추는 시간** 

이때는 "내 코드가 느려진 것"이 아니라 **JVM이 안전한 작업을 하기 위해 잠깐 전체를 정지** 시키는 것.

- GC 관점에서 STW는 "GC가 실행되는 동안 항상 100% 멈춘다"가 아닌 **GC 과정 중 일부 단계에서 반드시 멈춰야 하는 구간**이 존재한다는 의미
- 따라서 동시성 GC(G1, ZGC)를 써도 짧은 STW 구간은 남아있을 수 있다.

---

## STW가 발생하는 이유
> 핵심은 **정확성, 안전성**. 프로그램이 동시에 객체를 만들고 참조를 바꾸는데, 그 중간에 GC가 메모리를 만지면 데이터가 깨질 수 있다.

대표 이유들:
- **A. 객체 그래프를 정지된 상태에서 안전하게 보기 위해**
	GC는 누가 누구를 참조하는지를 기준으로 살아있는 객체를 판단한다.
	애플리케이션 스레드가 계속 참조를 바꾸면 GC가 보는 순간순간의 그래프가 흔들려서 정확한 판정이 어렵다. (동시성, Race Condition)
<br>

- **B. 힙 정리 중 객체 이동, 압축이 필요할 때**
	많은 GC는 Fragmentation(단편화)를 줄이기 위해 객체를 **복사하거나(Compaction) 이동**시킨다.
	이때 주소가 바뀌므로 **모든 참조를 업데이트**해야 하고 이 과정을 안전하게 하려면 STW가 필요해지는 구간이 생긴다.
<br>

- **C. Safepoint로 모두를 동기화 해야할 때**
	STW는 보통 **Safepoint**에서 발생한다.
	JVM이 "지금 멈춰도 안전한 지점"에서 모든 스레드를 멈추고, GC나 내부 작업을 한다.


STW는 GC 이외에 클래스 재정의, 디옵티마이즈(depot), 코드 캐시 관련 작업 등 JVM 내부 작업에서도 발생할 수 있다.

---

## STW 최소화 방법
> **GC 선택, 힙/튜닝, 코드/할당 패턴 개선**

1. **GC 선택, 목표에 맞추기**
	- 지연시간이 중요하면(웹, 실시간) : G1, ZGC, Shenandoah 계열을 고려
	- 처리량이 더 중요하면(배치) : throughput 성향 GC도 선택 가능
	- 중요한 것은 **"최신 GC는 STW를 없앤다"가 아니라** STW를 짧게 만들거나 긴 STW 빈도를 낮추는 방향

<br>

2. **힙 사이즈/세대 구조로 빈도 줄이기**
	- 힙이 너무 작으면 GC가 자주 돌아서 STW가 자주 튐
	- Old가 빨리 차면 Major / Full 성격의 GC가 늘고, STW가 길어질 확률이 커짐
	- Young이 너무 작으면 Minor GC가 너무 잦아짐
	- **"자주 짧게" vs "가끔 길게"의 트레이드 오프를 로그로 확인하면서 맞추는게 핵심**

<br>

3. **코드레벨에서 할당률 낮추기 (효과 큼)**
	STW는 결국 "GC가 할일이 많으면" 늘어난다.
	- 객체를 너무 많이 만들면 Eden이 금방 차서 Minor GC가 잦아진다.
	- 큰 객체, 임시 객체(문자열, 컬렉션) 남발하면 Old 승격이 늘어난다.
	
	해결 방향
	- 불필요한 객체 생성 줄이기(루프 내부, 요청당 다량 생성)
	- 큰 배열/버퍼 재사용 전략, 단 과도한 풀링은 부작용 가능
	- 문자열 concat 남발, 임시 컬렉션 생성 패턴 점검

<br>

4. **관측이 먼저, GC 로그/JFR로 원인 분리**
	STW 줄이려면 어떤 GC가, 얼마나, 왜 멈추는지 봐야한다.
	- GC 로그로 pause time 빈도, Young / Old promotion 실패 여부 확인
	- p95, p99 latency랑 STW 타이밍이 겹치는지 확인


---
## 관련 문서
- [[GC]]

