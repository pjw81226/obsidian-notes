# GC 

## 개요

> [!note] 개념설명
> 프로그램이 더이상 참조하지 않는 객체(garbage)를 찾아서 힙 메모리를 자동으로 회수하는 매커니즘

- **안쓰는 객체를 어떻게 판단하는가?**
	보통 루트에서 도달가능한 객체는 살아있음, 도달 불가능한 객체는 garbage로 보고 회수한다.
- **왜 성능 이슈가 생기는가?**
	GC는 메모리를 회수하는 동안 일시정지가 생길 수 있고, 힙이 커지거나 객체 할당이 많으면 지연 / CPU 사용량이 튈 수 있다.

## 핵심 개념
- [[메모리-구조]]
- [[Stop-The-World (STW)]]

## GC 알고리즘
- [[GC-알고리즘/Serial-GC]]
- [[GC-알고리즘/Parallel-GC]]
- [[GC-알고리즘/G1GC]]
- [[GC-알고리즘/ZGC]]

## 실무 활용
- [[GC-튜닝]]
- [[GC-모니터링]]

## G1GC vs ZGC

**ZGC가 더 맞는 상황**

- 지연시간(tail latency)이 최우선일 때  
	- p99/p99.9를 짧게 유지해야 하고, GC로 인한 긴 멈춤을 거의 없애고 싶을 때(설계 목표가 저지연).
- 힙이 큰 편(수십 GB~) 이고 힙이 커질수록 G1의 pause 변동이 부담될 때
- CPU/메모리 여유가 있는 서비스 
	- ZGC는 로드 배리어 + 동시 작업으로 짧은 멈춤을 얻는 대신 어느 정도 **오버헤드(CPU throughput)** 를 치름

즉, pause 시간과 GC가 일하는 동안의 처리시간은 짧으나, CPU 오버헤드가 크고 힙 공간이 충분해야함. 
시스템의 스펙은 좋으나 힙이 너무 커서 G1의 pause 시간이 부담될 때 사용하기 좋음.


**G1GC**
- 균형형 기본값이 필요할 때(대부분의 서버 앱) :  처리량도 중요하고, pause는 합리적인 수준이면 충분할 때
- 메모리가 타이트하거나 컨테이너 제한이 빡빡한 환경(헤드룸이 넉넉하지 않음)
- 처리량이 더 중요하고, pause는 100~200ms 정도까지는 허용 가능한 경우


## 질문

**ZGC는 처리시간이 짧아서 pause 되는 시간이 힙의 공간과 상관없이 짧음. 그럼 처리량도 많은거 아닌가? 왜 처리량을 희생한다고 말하는걸까.**

- pause(멈춤)이 짧다 = 처리량(throughput)이 많다  : 항상 성립하지 않음. 다른 지표
- **Pause time**: STW 시간이 얼마나 짧은가
- **Throughput**: 전체 시간 중 애플리케이션이 실제 일을 한 비율/양이 얼마나 큰가

> ZGC는 STW를 짧게 만드는 대신 GC 일을 애플리케이션이 돌아가는 동안(동시) 많이 한다.
> 즉 멈춤은 줄지만, 일하는 도중에 계속 옆에서 GC가 CPU를 쓰기때문에 앱이 쓸 수 있는 자원이 줄 수 있는 것.


## 퀴즈
