# GC 모니터링

## 모니터링 도구
### jstat (가볍고 빠른 실시간 숫자)
**장점:** 서버에 붙어서 바로 볼 수 있음(오버헤드 낮음)  
**한계:** “왜” 늘어나는지(어떤 객체가)까지는 못 봄
```bash
# PID 확인
jps -l

# 1초마다 GC/힙 요약 (퍼센트 기반)
jstat -gcutil <pid> 1000

# 1초마다 GC/힙 상세 (용량/사용량)
jstat -gc <pid> 1000

# 마지막 GC 원인까지 같이 보기
jstat -gccause <pid> 1000

```

> 보는 팁: “현재 값”보다 **추세(계속 올라가나/리셋되나)** 가 더 중요함.


### jvisualvm (원격/로컬에서 무슨 객체가 먹는지 보기)
**장점:** 힙/스레드/CPU, 샘플링, 클래스/인스턴스 현황, 힙덤프 분석 가능  
**한계:** 운영 서버에선 연결/권한/오버헤드 이슈가 있을 수 있음(가능하면 스테이징에서 먼저)

주로 보는 메뉴
- **Monitor 탭**: Heap 사용량 그래프, GC 활동(톱니 모양), CPU/Thread
- **Sampler**: CPU/Memory 샘플링(“뭐가 할당을 많이 하나” 힌트)
- **Heap Dump**: 메모리 누수 의심 시 결정타(어떤 객체가 남아있나, Dominator tree)


### GC 로그 (가장 확실한 원인과 타이밍)
**장점:** GC가 _언제, 왜, 얼마나 멈췄는지_ 가장 정확  
**한계:** 해석 습관이 필요
``` json
-Xlog:gc*,gc+heap=info,gc+pause=info,safepoint:file=gc.log:time,uptime,level,tags
```
권장로그 옵션

로그에서 보려는 것
- 어떤 GC가 발생했는지(Young/Mixed/Full, ZGC cycle 등)
- Pause가 얼마였는지
- GC의 트리거(Allocation Failure, Humongous, Metadata GC Threshold 등)
- GC 이후 힙이 얼마나 줄었는지(회수 효율)

## 주요 지표
### GC 빈도
- **Young GC가 너무 자주**: 할당이 많거나(객체 생성 폭발), Young이 작을 수 있음
- **Full GC가 발생**: 진짜 경고 신호(자주면 거의 무조건 성능/지연 문제)

체크 포인트
- “초당 YGC 횟수”가 계속 높나?
- FGC가 **0에 가깝게 유지되는지**(G1/ZGC라도 Full은 가능한 한 드물어야 함)

### GC 시간 (= 멈춘 시간/혹은 GC가 먹는 시간)

- `YGCT/FGCT/GCT`(jstat)와 로그의 pause를 같이 봄
- 운영 관점에서 중요한 건 보통 **“총 GC 시간 비율” + “가끔 튀는 최대 pause”**

간단 기준(감으로)
- GC가 CPU 시간을 너무 먹으면(예: 총 시간 비율이 눈에 띄게 큼) 처리량이 떨어짐
- pause가 길게 튀면(특히 Full, 또는 G1 Mixed가 길어짐) 사용자 체감이 나빠짐

### Heap 사용률(특히 “GC 후에도 남는 양”)
- 핵심은 **“GC 후 Old가 얼마나 내려가냐”**
- Old(또는 전체 힙)가 **GC 후에도 계속 우상향**이면:
    - 누수 가능성(또는 캐시/맵/세션이 계속 누적)
    - 힙이 워크로드 대비 작음
    - 메타스페이스/클래스 누수면 `M`이 계속 상승


## 문제 진단
### A) Young GC가 너무 잦고, 성능이 떨어짐

증상
- `YGC`가 초당 여러 번, `YGCT`가 빠르게 증가
- CPU가 GC에 많이 쓰이는 느낌

원인 후보
- 객체 생성량 과다(틱 루프, 매 프레임 컬렉션/문자열 생성 등)
- Young이 너무 작음(힙 자체가 작거나, Young 비율이 낮음)
    
다음 액션
- 코드에서 **할당 줄이기**(객체 재사용, 버퍼 재사용, 문자열/컬렉션 생성 최소화)
- 힙/Young 사이즈 조정(G1이면 Young 비율/목표 pause 조정으로 간접 영향)



### B) Full GC가 발생하거나 가끔 엄청 길게 멈춤

증상
- `FGC`가 증가    
- GC 로그에 Full/Allocation Failure/Promotion Failure 같은 트리거
- 사용자 체감 “뚝 끊김”

원인 후보
- Old가 꽉 참(힙 부족)
- 승격(promotion)이 많이 일어나 Old 압박
- 큰 객체/단편화(특히 G1에서 humongous 패턴)

다음 액션
- **Xmx 상향**(가능하면 가장 효과적)
- 누수/캐시 무한증가 의심 시 힙덤프 분석(VisualVM)
- G1이면 로그에서 **Humongous** 여부 확인(큰 배열/버퍼 패턴 점검)

### C) 힙 사용량이 GC 후에도 계속 상승(누수 의심)

증상
- 톱니 모양 그래프인데 바닥선이 계속 올라감
- Old 사용률이 장기적으로 우상향

원인 후보
- 컬렉션/맵/캐시/세션이 계속 누적
- 리스너/콜백 등록 해제 누락
- 클래스 로더 누수(플러그인/리로드 환경) → Metaspace도 같이 상승 가능

다음 액션(정석 루트)
1. VisualVM에서 **Heap Dump**
2. Dominator/Retained Size 큰 것 확인
3. “누가 잡고 있나(참조 체인)” 추적


### D) Metaspace(M)가 계속 증가
증상
- `M`이 계속 우상향, 갑자기 GC가 잦아지거나 OOM: Metaspace

원인 후보
- 동적 클래스 생성/프록시 남발
- 클래스 로더 누수(특히 핫리로드/플러그인)

다음 액션
- 힙덤프 + 클래스 로더 관점 분석(VisualVM에서 클래스/로더)
- 근본 원인 제거가 최우선(단순히 MaxMetaspaceSize로 막으면 증상만 지연)


## 진단하는 순서

1. `jstat -gcutil pid 1000`로 **YGC/FGC, O/M 추세**를 먼저 본다
2. GC 로그로 **발생 원인 + pause 튐 구간**을 확인한다
3. “GC 후에도 Old가 안 내려간다”면 VisualVM **Heap Dump**로 누수 확인


## 관련 문서
- [[GC]]
- [[GC-튜닝]]

