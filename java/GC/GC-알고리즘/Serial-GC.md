# Serial GC
가장 단순하고 기본적인 GC 방식으로 **"단일 스레드"** 로 동작하는 것이 핵심
## 특징
- **단일 스레드 방식:** 가비지 컬렉션을 수행하는 스레드가 단 하나. 따라서 GC가 실행되는 동안 **Stop-The-World** 가 발생하여 애플리케이션의 모든 스레드가 멈춘다.
- **낮은 오버헤드:** 스레드 간의 통신이나 Context Switch 비용이 없어 리소스 소모가 적다.
- **알고리즘:** Old 영역에 대해 **Mark-Sweep-Compact** 알고리즘을 사용한다.

## 동작 방식
Serial GC는 힙 영역을 Young 영역과 Old 영역으로 나누어 다음과 같이 동작한다.
- **Young 영역 (Minor GC):**
	- 새로 생성된 객체는 Eden 영역에 할당
	- 공간이 부족하면 살아있는 객체만 Survivor 영역으로 복사하고 나머지 죽은 객체는 삭제
	- 오래 살아남은 객체는 Old 영역으로 promotion
- **Old 영역 (Major GC / Full GC):**
	- **Mark-Sweep-Compact** 알고리즘을 사용
	- 1. Mark: 살아있는 객체를 식별
	- 2. Sweep: 힙의 앞부분부터 확인하여 살아있는 객체만 남기고 나머지를 제거
	- 3. Compact: 살아있는 객체들을 힙의 시작 부분으로 차곡차곡 채워 넣음.


## 사용 시나리오
- **CPU 코어가 1개인 환경:** 멀티 스레드로 GC를 수행해도 코어가 1개라면 Context Switching 비용만 발생하므로 Serial GC가 가장 효율적이다.
    
- **소규모 메모리 (Small Heap):** 대략 100MB ~ 수백 MB 정도의 작은 힙 크기를 가진 애플리케이션에 적합
    
- **Client-side 애플리케이션:** 잠깐의 멈춤이 사용자 경험에 치명적이지 않은 데스크탑 애플리케이션이나 배치 작업.

## 장단점
| **구분** | **내용**                                                                                                                                                         |
| ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **장점** | • 알고리즘이 단순하고 구현이 쉬움<br><br>• GC를 수행하는 스레드가 하나이므로 스레드 생성/동기화 비용이 없음<br><br>• 적은 메모리와 CPU 리소스를 사용하는 환경에서 효율적임<br>                                                |
| **단점** | • 멀티 코어 CPU 환경에서도 하나의 코어만 사용하므로 자원을 최대한 활용하지 못함<br><br>• **Stop-The-World 시간이 김** (힙 사이즈가 커질수록 멈추는 시간이 비례하여 증가)<br><br>• 웹 서버와 같이 응답 속도가 중요한 대규모 서비스에는 부적합합니다. |

## JVM 옵션
```bash
-XX:+UseSerialGC
```
다음 옵션을 사용해서 secrial GC를 활성화 할 수 있다.

## 관련 문서
- [[../GC]]

