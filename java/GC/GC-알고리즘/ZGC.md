# ZGC (Z Garbage Collector)

핵심은 **살아있는 객체를 찾고(mark), 옮기고(relocate), 회수(정리)하는 큰 작업을 STW가 아니라 concurrent로** application과 동시에 돌아가게함.

특성상 ZGC에서 FGC가 많이 나오지 않도록 설계되어있음. 즉, ZGC에서 FZC가 발생하는건 예외의 상황에 가깝다.

## 특징

- **초저지연(낮은 pause time)** 을 목표로 한 GC
	- “힙이 커져도 pause가 크게 늘지 않게” 설계됨
- 대부분의 작업을 동시(concurrent)로 수행하고, STW는 아주 짧게 가져감(루트 스캔 등)
- Region 기반, Compacting(압축/이동) GC
	- 단편화 문제를 줄이면서도, 이동을 동시로 처리하는 쪽
- 구현 핵심 키워드
	- Colored pointers, Load barriers (포인터에 메타데이터를 싣고, 접근 시 배리어로 정합성 유지)


## 동작 방식
ZGC는 “멈추고 한 번에 정리”가 아니라 동시에 마킹하고 동시에 이동(재배치)해서 STW를 짧게 만드는 방식

**1) Concurrent Mark(동시 마킹)**
- 살아있는 객체를 표시하는 큰 작업을 애플리케이션과 같이 진행

**2) Concurrent Relocation(동시 이동, 사실상 동시 압축)**
- 살아있는 객체를 다른 Region으로 동시에 옮기며 단편화를 줄임(Compacting)

**(3) Load Barrier로 어디가 최신 위치인지 보장**
- 스레드가 객체를 읽을 때 배리어를 통해 옮겨졌으면 새 주소로 자연스럽게 따라가게 해서, 이동을 STW가 아니라 **동시에** 가능하게 만듦

**STW가 아예 없는 건 아님**
- 루트 스캔 같은 아주 짧은 구간은 STW로 처리하도록 설계



## 사용 시나리오

- **지연시간이 중요한 서비스**
    - API 서버, 실시간성 사용자 트래픽, tail latency(최악 지연) 줄이고 싶을 때
        
- **힙이 큰 서비스**
    - 수백 MB부터 TB급까지도 대상, 큰 힙에서 pause를 짧게 유지하려는 목적
        
- 반대로, 이런 경우는 신중
    - CPU가 이미 빡빡한 환경(배리어/동시 스레드로 CPU 오버헤드가 생길 수 있음)
    - 힙 여유(헤드룸)가 부족한 환경(동시 GC는 돌아가는 동안 할당을 버텨야 함)

## JVM 옵션
`-XX:+UseZGC`
`-Xmx<size>` (중요)
- ZGC는 동시 GC라 **라이브셋 + 할당을 버틸 헤드룸**이 필요, 보통 “메모리를 넉넉히 줄수록” 유리

자주 쓰는 실무 옵션
- `-Xms<size>` 를 `-Xmx` 와 같게(메모리 uncommit로 인한 지연을 피하려는 목적)

- OS로 메모리 반환 관련
    - `-XX:-ZUncommit` (반환 비활성화)
    - `-XX:ZUncommitDelay=<seconds>` (미사용 메모리를 OS에 반환하기 전 대기, 기본 300초 설명)
        
- 스레드(필요 시)    
    - `-XX:ConcGCThreads=<n>` (동시 GC 스레드 수)
        
- 세대 모드 관련(버전 차이 주의)
    - 최신에선 ZGC는 generational이 기본, 비세대 모드는 제거 흐름
    - 그래서 보통은 `-XX:+UseZGC` 만으로 충분한 쪽으로 가는 추세

## 장단점

장점
- 매우 짧은 pause를 목표로 하고, 힙이 커져도 pause가 크게 늘지 않도록 설계
- 동시 이동(사실상 동시 압축)이라 단편화에 강한 편
- 큰 힙, 지연시간 민감 서비스에 적합

단점
- 배리어, 동시 스레드 등으로 처리량 손해가 날 수 있음(낮은 지연의 비용)
- 힙 헤드룸이 부족하면 동시 GC가 따라가지 못해 할당 지연(Allocation stall) 같은 현상이 생길 수 있음
	`-Xmx` 설계가 중요
- 튜닝 포인트가 pause 목표값 보다도 **메모리 여유와 할당 패턴** 쪽에 더 걸리는 편


## 관련 문서
- [[../GC]]

