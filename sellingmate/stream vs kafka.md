
| 기능                                | Redis Pub/Sub    | Redis Streams  | Apache Kafka    |
| --------------------------------- | ---------------- | -------------- | --------------- |
| 순서 보장                             | △ (연결된 동안만)      | O (Stream 내)   | O (Partition 내) |
| Offset/Commit 관리<br>(Auto/Manual) | X (불가능)          | O (가능)         | O (가능)          |
| Producer ACK                      | X (전송 성공 여부만 확인) | O (ID 반환으로 확인) | O (acks 설정)     |
| 데이터 지속성                           | 없음 (휘발성)         | 있음 (메모리/디스크)   | 있음 (디스크)        |

### Redis Stream
#가벼움 #빠름 #간편함
- In Memory
	- 속도가 매우 빠름. 하지만 데이터를 무한정 쌓아두기 어려움.
	- 주로 삭제 후 처리하거나 최대 길이를 설정하여 운영
- 인프라 재사용
	- 우리 서비스에 이미 붙여놓을 거니까 그냥 갖다 쓰면됨


### Kafka
#거대함 #견고함 #확장성
- 디스크 기반
	- 데이터를 디스크에 쓰기 때문에 전원이 나가도 안전하며 비용 효율적으로 데이터를 오래 보관 가능
- Replay
	- 며칠 전, 혹은 몇달 전의 데이터를 다시 처음부터 읽어서 재처리하는 것이 자유러움
- 무거운 운영
	- 다만 브로커, KRaft, 파티션 리밸런싱 등의 운영난이도가 높음


여기부터는 조금 지루하고 현학적임

**메세지의 소비와 상태관리**
- 카프카
	- 기본적으로 오프셋을 컨슈머가 관리한다.
	- 즉 컨슈머가 원하는 시점으로 오프셋을 되돌려 작업을 다시 처리하는것이 매우 자유로움
	- 파티션은 유명한 병렬 단위임 ; ;

- 레디스 스트림
	- ID기반임. 각 메세지는 생성시간 기반의 고유 ID를 가짐
	- PEL (Pending Entries List) : Redis는 어떤 소비자 그룹의 누가 어떤 메세지를 읽어갔고 아직 ACK을 안보냈는지 서버 내부에서 관리한다.
	- 파이썬 워커 코드는 간단해질 것. 그냥 나한테 할당된거 달라고 요청하면 레디스는 알아서 안읽은 것을 줌

아무튼...
레디스 스트림은 scale out이 어려운 편. 카프카는 파티션 늘리고 컨슈머도 늘리면 되니까 괜찮은데 레디스 스트림은 파티션 개념이 없음. 여러 컨슈머가 그냥 하나의 스트림에 붙어서 가져가면 레디스가 라운드로빈으로 분배해줌
다만 컨슈머 늘리고 그룹으로 묶으면 LAG은 줄어듬 수행에서의 확장은 편함

-> 여기에서 오는 단점은 카프카는 **메세지를 저장하는 곳에 대한 수평확장이 쉬움** 근데 레디스는 스트림 하나 (키 하나)에 여러대의 컨슈머가 붙는 구조라 단일 노드임 레디스에 대한 수평확장은 어려움


### 아무튼..
당장은 레디스 스트림을 사용할 것
사용하는 이유는
- 이식성 : 어차피 레디스 사용하는데 그거 가져다 쓰면 좋으니까
- 편의성 : 카프카는 설정이 너무 귀찮음 주키퍼 안쓰고 크래프트 쓴다고 해도 별로임 설정값이 너무많음
- 굳이임
	- 이게 가장 큰 이유
	- 카프카의 장점을 사용할 이유가 없음
		- 하나의 작업 request의 크기가 얼마일지 모르겠지만 그렇게 크지는 않을 것 같음
		- 그리고 사용자도 별로 없을 것 같음
		- 초당 5만 ~ 10만건씩 떨어지는것도 아님
		- 어차피 디비에도 저장할건데 굳이 작업 요청을 오래 들고있어야할 이유가 없음

만약 TPS가 5만건 10만건씩 늘어나고  하루에 데이터가 100GB 씩 쌓이게 되면 전환을 고려해야할 듯 근데 그정도 서비스면 내가 개발 안하고 있을 것 같은데 ? 

