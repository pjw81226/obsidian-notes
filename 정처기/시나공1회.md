
##### 1번 워크스루와 인스펙션 (1과목)
![[Pasted image 20260117140232.png]]
- 워크스루와 인스펙션은 개발단계에서 오류를 미리 찾아내기 위한 Review(검토) 기법들
- 워크스루
	- **내가 짠 코드인데, 한번 같이 봐줄래?** 라고 가볍게 요청하는 상황, 비공식적
	- 주도자 : 개발자 본인이 회의를 주도
	- 목적 : 오류 탐색, 팀원 교육(지식 공유), 아이디어 수집
		- 워크스루는 코드뿐만 아니라 설계도, 요구사항 명세서 등 소프트웨어 개발 전 과정에 적용 가능
		- 코드를 직접 실행하지 않고 머릿속으로 시뮬레이션해 보는 것이므로, 복잡한 로직이나 알고리즘의 흐름을 이해하는 데 유용하다.
		- 워크스루의 핵심은 **수작업** 사람이 모여서 테스트케이스를 직접 따라가 보는 것
- 인스펙션
	- 규칙에 따라 내 코드를 엄격하게 심사해 줘." 라는 느낌의 공식적인 검토 과정
	- 주도자 : 훈련된 주재자가 회의를 이끔
	- 목적 : 결함 발견 및 품질 향상이 최우선 목표
		- 동작의 이해보다는 결함발견.
		- 테스트케이스를 사용하는 것이 아닌 체크리스트를 두고 코드를 훑으며 규칙위반 찾음
		- 1번 보기는 맞음. 요구사항 정의서, 설계도, 테스트 계획서 등 소프트웨어 개발 전 과정의 산출물에 적용가능하다.
- 정답은 3번


##### 2번 결합도 (1과목)
![[Pasted image 20260117140240.png]]
- 결합도는 소프트웨어 모듈 간에 얼마나 끈끈하게 연결되어있는가를 나타내는 척도
	- 자료결합도
		- 모듈간의 인터페이스가 **자료 요소**만으로 구성됨
	- 스탬프결합도
		- 배열이나 레코드 등의 **자료구조가 전달**될 때의 결합도
	- 제어결합도
		- **제어신호**를 이용하여 통신하거나 제어 요소를 전달하는 결합도
	- 외부결합도
		- 데이터를 **외부의 다른 모듈**에서 참조할 때의 결합도
	- 공통결합도
		- 공유되는 **공통 데이터 영역**을 여러 모듈이 사용할 때의 결합도
	- 내용결합도
		- 다른모듈의 **내부 자료를 직접 참조**하거나 수정할 대의 결합도


##### 8번 UI 설계원칙(1과목)
![[Pasted image 20260117151823.png|500]]
- 멀티 운용성 따위는 없다.. 정답 3번
	![[Pasted image 20260117152517.png|300]]

##### 9번 자료 흐름도(1과목)
![[Pasted image 20260117140316.png]]
- 자료흐름도 예시
	![[Pasted image 20260115183334.png|400]]
	![[Pasted image 20260115183204.png|400]]
- 정답은 2번


##### 11번 UML 관계 (1과목)
![[Pasted image 20260117140436.png]]
- **Association (연관관계)** 
	- 한클래스가 다른클래스를 필드로 가지고있어 언제든 참조 가능 
	  (실선 + 화살표) (선생님 ── 학생)
- **Aggregation (집합관계)** 
	- 부분이 전체에 속해있지만 독립적인 생명주기, 전체가 사라져도 부분은 살아남을 수 있음. 
	  (비어있는 마름모) (컴퓨터 ◇── 프린터)
	- ==약한 포함==
- **Composition (합성관계)**
	- 부분이 전체에 강력하게 종속, 생명주기가 함께. 전체가 사라지면 부분도 사라짐
	  (찬 마름모) (집 ◆── 방)
	- ==강한포함==
- **Generalization (일반화 관계)**
	- 자식클래스가 부모 클래스의 속성을 물려받음
	  (비어있는 삼각형) (동물 ◁— 개 (개는 동물이다.))
	- ==상속 관계==
- **Realization (실체화 관계)**
	- 추상메서드만 있는 인터페이스를 실제 클래스가 구현하여 기능을 완성
	  (점선 + 비어있는 화살표) (날 수 있는 ◁ - - - 새 )
	- ==인터페이스 관계==
- **Dependency (의존관계)**
	- 한클래스가 다른 클래스를 매개변수, 리턴타입, 지역변수로 잠깐 사용하는 관계
	  (점선 + 열린화살표) ( --> )
	- ==*상대방이 변하면 나도 영향을 받지만 계속 참조하고 있지는 않는다. (일시적)*==


##### 12번 Class, Package, Object, Message (1과목)
![[Pasted image 20260117140511.png]]
- Class
	- 객체를 설계하기 위한 틀, 설계도
	- 객체가 가져야할 속성, 연산 정의
- package
	- 서로 관련된 클래스나 인터페이스를 묶어놓은 컨테이너
	- 접근 제어를 도움
- object
	- 클래스에 따라 메모리 상에 구현된 인스턴스
- Message
	- 객체들 간에 상호작용을 하기 위한 수단
	- 객체에게 어떤 행위(Method)를 수행하라고 지시하는 명령


##### 14. 파이프필터 (1과목)
![[Pasted image 20260117140550.png]]
- **파이프필터 아키텍처**
	- 데이터 흐름이 있는 시스템을 위한 구조.
	- 데이터가 여러 단계의 처리 과정을 거치며 변환되고 각 단계는 파이프를 통해 연결되는 형태이다.
	- **필터** : 데이터를 받아 처리하고 내보내는 처리기. 각 필터는 독립적
	- **파이프** : 한 필터의 출력 데이터를 다음 필터의 입력으로 전달하는 통로
- 해설
	1. 노드와 간선은 네트워크 토폴로지 혹은 일반적인 그래프 구조
	2. 정답.
	3. 계층모델은 계층형 아키텍처 (OSI 7계층, Layered 구조)
	4. MVC 패턴 이야기

##### 17. Fan-In / Fan-Out (1과목)
![[Pasted image 20260117140653.png]]
- Fan-In은 어떤 모듈을 제어하는 모듈의 수를 의미한다.
- Fan-Out은 어떤 모듈에 의해 제어되는 모듈의 수를 의미한다.
- 정답은 1번

##### 19. 럼바우 분석기법 (1과목)
![[Pasted image 20260117140813.png]]
- 럼바우 분석 기법
	- 객체지향 분석기법
	- 소프트웨어 구성요소를 객체, 동적, 기능의 세가지 관점으로 나누어 분석한다.
- 럼바우의 3가지 모델링
	- 객체 모델링 ➔ 동적 모델링 ➔ 기능 모델링
		- 객체모델링 : 시스템의 정적구조를 표현 (객체 다이어그램)
		- 동적모델링 : 시간의 흐름에 따른 객체의 상태변화와 제어 흐름을 표현 (상태 다이어그램)
		- 기능모델링 : 데이터 값의 변화 과정을 표현 (자료흐름도)
- 정답은 4번

##### 20. 미들웨어 1과목)
![[Pasted image 20260117140831.png]]
- 미들웨어
	- 분산 컴퓨팅 환경에서 서로 다른 기종 간을 연결한다.
	- 운영체제와 응용프로그램 사이에서 다양한 서비스를 제공한다.
	- 위치 투명성을 제공한다.
	- 사용자가 미들웨어의 내부 동작을 확인하려면 별도의 응용소프트웨어를 사용해야한다.

##### 21 소프트웨어 테스트 (2과목)
![[Pasted image 20260117140928.png]]
- 화이트박스 테스트
	- 내부 소스코드와 로직을 보면서 수행하는 테스트
	- 주로 개발자가 수행
	- 모듈의 논리적인 구조를 체계적으로 점검
- 블랙박스 테스트
	- 입력과 출력만 확인하여 기능이 제대로 동작하는지 보는 테스트
	- 주로 테스터나 사용자가 수행
	- 프로그램의 내부 구조는 고려하지 않는다.
- 기본경로는 싸이클이나 순환을 포함한다. 
	- 그냥 하향식으로 내려가는 **알고리즘 수도 코드 그래프를 생각**해보자. **반복문 표현을 어떻게하는가?**
	- 당연히 순환과 싸이클을 허용한다.

##### 22. DRM 기술 (2과목)
![[Pasted image 20260117140943.png]]
- 소프트웨어 패키징시 다른 여러 콘텐츠 및 단말기간 DRM 연동을 고려한다.
- DRM의 구성요소
	- **콘텐츠 제공자 :** 콘텐츠를 만든 사람 (저작권자)
	- **콘텐츠 분배자 :** 암호화된 콘텐츠를 유통하는 쇼핑몰 등
	- **패키저 :** 콘텐츠를 암호화하고 메타데이터를 결합하는 도구
	- **클리어링 하우스 :** 저작권 사용료를 정산하고, 라이선스(사용 권한)를 발급 및 관리하는 곳입니다
	- **DRM 컨트롤러** : 배포된 콘텐츠의 이용 권한을 통제하는 프로그램

- DRM의 기술요소
	- 콘텐츠 암호화 및 키 관리
	- 콘텐츠 식별체계 표현
	- 라이센스 발급 및 관리
	- 크랙 방지 기술
	- 정책 관리 기술

##### 23. 형상관리 (2과목)
![[Pasted image 20260117141035.png]]
- chief programmer team
	- 프로젝트 수행 시 개발 조직을 구성하는 방법(팀 편성 기법) 중 하나 (한 명의 책임 프로그래머에게 권한을 집중시키는 중앙 집중형 구조를 말한다.)
- 형상 관리에서 변경 사항을 심의하고 승인하는 조직은 보통 **형상 통제 위원회(CCB, Configuration Control Board)** 라고 부른다.

##### 25. EAI (2과목)
![[Pasted image 20260117141050.png]]
- EAI
	- 서로 다른 시스템들을 서로 연결하여 데이터를 주고받을 수 있게 통합하는 솔루션이나 기술
	- 과거에는 시스템 A와 시스템 B를 연결하려면 1:1로 직접 API를 짬 (Point-to-Point)
	- 시스템이 100개가 되면 연결이 수천 개가 되어 관리가 불가능해짐 (Spaghetti Code)
	- **EAI**를 도입하면 중앙에 '미들웨어'를 두고, 모든 시스템이 이 미들웨어를 통해 표준화된 방식으로 통신

- EAI의 네가지 핵심 구축 유형
	- Point-to-Point
		- 가장 기초적인 방식, 애플리케이션끼리 1:1로 직접 연결
	- Hub & Spoke
		- 중앙에 **허브(Hub)** 중계 서버를 두고, 모든 데이터가 이 허브를 거쳐 가도록 하는 방식
	- Message bus
		- 미들웨어(버스)를 두어 애플리케이션들이 메시지를 주고받는 방식
	- Hybrid
		- Hub & Spoke와 Message Bus의 장점을 혼합한 방식
		- 그룹 내에서는 Hub & Spoke를 쓰고, 그룹 간에는 Message Bus를 쓰는 등 유연하게 구성

##### 26. 파레토법칙 (롱테일 법칙 반대) (2과목)

![[Pasted image 20260117141100.png]]

##### 27. 테스트 오라클 (2과목)
![[Pasted image 20260117141207.png]]
- 테스트 오라클
	- 토탈 오라클 : **모든** 입력값에 대해 기대하는 결과를 확인한다. 
	- 샘플링 오라클 : 특정 몇몇 입력값에 대해서만 결과를 확인한다
	- 휴리스틱 오라클 : 샘플링 오라클을 개선한 것이다. **특정 입력값**은 정확하게 확인, 나머지는 통계적 추정(직관)**으로 처리한다
	- 일관성 검사 오라클 : 애플리케이션 변경 전후의 **실행 결과가 일관성 있는지** 확인한다.

- 테스트케이스의 수행 전후의 결과값이 동일한지 확인하는 것은 이상한 말.

##### 28. IPSec (2과목)
![[Pasted image 20260117141226.png]]
- **IP 패킷 자체를 암호화하고 인증**하여 해커가 패킷을 훔쳐보거나 변조하지 못하게 만드는 기술
- **암호화방식은 양방향 일방향 둘 다 사용한다.**
	- AH
		- 인증 + 무결성 검증 : 보낸 사람이 맞는지, 중간에 내용이 안 바뀌었는지만 확인
	- ESP
		- 인증 + 무결성 + 기밀성 (암호화) : 데이터 내용까지 **암호화**해서 아무도 못 보게 만듬
- **IPSec의 동작모드**
	- 전송모드 : IP 패킷의 데이터(payload) 부분만 암호화
	- 터널모드 : 헤더 포함 IP 패킷 전체를 암호화, 새로운 IP 헤더를 붙인다. 

##### 29. 스택 응용 (2과목)
![[Pasted image 20260117141316.png]]
- 인터럽트 처리 : 현재 작업 상태를 스택에 정리 해놓고 다시 와서 꺼내씀
- 수식의 계산 : 컴파일러가 수식 계산할때 연산자 우선순위 맞추기 위해서 후위 표기법으로 변환, 스택 이용
- 서브루틴의 복귀 번지 저장 : 함수 호출할때 현재 주소를 스택에 넣어놓고 이동 (어셈블리 생각)
- 운영체제의 작업 스케줄링은 기반이 FIFO

##### 30. 선택 정렬 (2과목)
![[Pasted image 20260117141347.png]]
- 가장 작은 값을 선택해서 맨앞의 값과 자리를 바꾸는 방식
- 한번 자리를 바꾸면 돌아온 자리는 **고정**
- 회차가 늘어날 수록 확인해야하는 수의 개수가 하나씩 줄어듬


##### 31. 해싱함수 (2과목)
![[Pasted image 20260117141410.png]]
- **해싱함수** : 해시 값을 만드는 방법
	- 제곱법 : 값을 제곱한뒤, 몇비트를 잘라서 주소로 사용한다.
	- 숫자 분석법 : 키 값의 각 자릿수 분포를 보고 고르게 분포된 자릿수를 뽑아서 쓴다.
	- 제산법 : 가장 흔한 방식, 값을 소수(Prime Number)로 나눈 나머지(Mod)를 주소로 사용한다.

- **해시 충돌 해결법** 
	- 개방주소법 : 충돌이 나면 옆 빈칸을 찾는 방식 (Linear Probing)
	- 체이닝 : 충돌이 나면 해당 칸에 리스트로 줄줄이 매다는 방식


##### 32. 인터페이스 구현 검증 도구 (2과목)
![[Pasted image 20260117141428.png]]
- 검증(테스트) 도구
	- **xUnit:** Java의 **JUnit**, C++의 CppUnit 같은 단위 테스트 프레임워크의 통칭
	- **STAF (Software Testing Automation Framework):** 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 자동화 테스트 프레임워크
	- **NTAF (Naver Testing Automation Framework):** STAF와 FitNesse의 장점을 결합하여 네이버에서 만든 테스트 자동화 프레임워크
- 시스템 통합 기술
	- **ESB (Enterprise Service Bus):**  **EAI**의 핵심 기술로, 기업 내 시스템들을 서로 연결해주는 **버스** 역할을 하는 미들웨어. 
	- 테스트 도구가 아닌 통신 인프라

##### 33. 스택 출력 (2과목)
![[Pasted image 20260117145800.png|500]]

- 문제의 의도는 push를 하면 A B C D 가 순서대로 들어오고 POP을 어느타이밍에 할지는 안정해져있는 상태
- 에서 나올 수 없는 결과를 찾는것.... 문제의 의도를 잘 파악하자.


##### 35. 소스코드 품질분석 도구 (2과목)
![[Pasted image 20260117141513.png]]
- 소스코드 품질 분석 도구
	- **코드를 실행하냐 안하냐** 를 기준으로 정적 분석, 동적 분석을 구분한다.
- 정적분석
	- 실행안하고 소스코드만 본다.
	- pmd, checkstyle, cppcheck
- 동적분석
	- 실행한다. 메모리 누수, 스레드 결함 성능 병목을 확인한다.
	- Valgrind, Avalanche


##### 36. 알파, 베타 테스트  (2과목)
![[Pasted image 20260117141529.png]]
- 인수테스트
	- 사용자 관점에서 제품을 평가하는 단계
	- 알파테스트 : 개발사 내부에서 개발자와 통제된 사용자가 함께 사용해보는 것
	- 베타테스트 : 실제 고객들에게 제품을 풀어서 써보게하는 것

- 단위테스트
	- 소프트웨어의 최소단위인 모듈 하나하나가 제대로 동작하는지 검사하는 것
	- 개발자가 직접
- 통합테스트
	- 단위테스트가 끝난 모듈들을 합쳤을 때 서로 데이터를 잘 주고받는지 검사하는 것
- 시스템테스트
	- 전체 시스템이 완전히 통합된 상태에서 기능적 요구사항과 비기능적 요구사항을 만족하는지 검사


##### 37. 테스트 드라이버 (2과목)
![[Pasted image 20260117142324.png]]
- 테스트 드라이버 vs 스텁
	1. 드라이버
		- Service를 테스트해야하는데 Controller가 아직 안만들어짐
		- Controller 흉내를 내서 Service에 데이터를 던져주는 가짜 모듈을 만듬 이걸 **드라이버**
		- **상향식 통합 테스트에 쓰인다.**
	2. 스텁
		- Service를 테스트해야하는데 호출해야할 Repository가 아직 안만들어짐
		- Repository 흉내를 내서 Service에 가짜 DB결과를 리턴해주는 모듈을 만듬 이걸 **스텁**
		- **하향식 통합 테스트에 쓰인다.**

##### 38. 소프트웨어 패키징 (2과목)
![[Pasted image 20260117142240.png]]
- 소프트웨어 패키징
	- 개발이 끝난 결과물을 고객에게 전달하기 위해 포장하는 과정
	- 새로짠 코드나 버그 수정 사항을 빌드해서 하나의 제품으로 묶는 과정
	- 패키징에는 단순 코드뿐만 아니라 README, Release Note, 메뉴얼 이 포함되어야함
	- 특정 컴퓨터에서만 돌아가는게 아니라, 일반적인 다양한 OS 환경에서 설치되고 실행될 수 있도록 표준화된 방식을 사용한다.
- 패키징은 무조건 **사용자 중심**

##### 41. DB 무결성 (3과목)
![[Pasted image 20260117141620.png]]
- 데이터베이스 무결성
	- 개체 무결성
		- 기본키는 Null이 될 수 없고, 중복될 수 없다.
	- 참조무결성
		- 외래키값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야한다.
	- 사용자 정의 무결성
		- 사용자가 정의한 제약조건에 만족해야한다.
	- 도메인 무결성
		- 속성 값이 정의된 도메인(범위)에 속해야한다.

##### 43. 트랜잭션 (3과목)
![[Pasted image 20260117141730.png]]
- ACID
	- 1번은 Commit과 Rollback에 관한 이야기, Atomicity(원자성), 트랜잭션은 더이상 분리되면 안된다.
	- 2번은 DB 고정요소(즉, 제약조건)에 관한 이야기. Consistency(일관성)에 관한 설명
	- 3번은 트랜잭션이 서로 독립되어야한다는 이야기. Isolation(격리성 / 고립성)에 관한 설명
- 4번은 Atomicity(원자성)에 관한 이야기 

##### 44. 분산 데이터베이스
![[Pasted image 20260117141827.png]]
- 분산 데이터 베이스
	- 지역 자치성(Local Autonomy)을 가지므로 각 지역 서버는 중앙의 간섭 없이 독립적으로 데이터를 처리할 수 있다.
	- 시스템 용량이 부족할 때 새로운 서버를 추가(Scale Out) 하기 용이하다
	- 분산 데이터베이스의 4대 투명성(위치, 중복, 병행, 장애)을 목표로한다. 사용자는 데이터가 어디에 있는지, 복제되었는지 신경쓰지 않고 사용할 수 있어야한다.

##### 45. 파티셔닝 방식
![[Pasted image 20260117141847.png]]
- Range Partitioning
	- 월별, 분기별 같이 연속적인 숫자나 날짜를 기준으로 범위를 지정하여 나누는 방식을 레인지 파티셔닝이라고 한다.
- Hash Partitioning 
	- 해시 함수를 적용하여 결과 값에 따라 데이터를 분산시킨다. 데이터가 고르게 분산되지만, 특정 범위를 조회하는데는 불리하다.
- Composite Partitioning 
	- 두가지 이상의 파티셔닝 방식을 결합한 것이다. (레인지로 나누고 그 안에서 해쉬로 나눔)
- List Partitioning
	- 특정 값의 목록을 기준으로 데이터를 분할한다.(한국, 미국 일본) 순서나 범위가 아닌 특정 카테고리 값에 적합하다.

##### 46. 관계형, 게층형, 네트워크형 구분하는 기준
![[Pasted image 20260117141934.png]]
- 데이터베이스의 종류는 데이터간의 관계를 어떻게 표현하느냐에 따라 구분된다.
	- 계층형 : 트리구조 (부모 - 자식 구조)
	- 네트워크형 : 그래프 구조 (망 형태)
	- 관계형 : 테이블 구조 (행과 열)

##### 47. SQL
![[Pasted image 20260117142010.png]]
- GRANT : 권한 부여
- REVOKE : 권환 회수

##### 48. 데이터베이스 설계 단계
![[Pasted image 20260117142019.png]]
- 데이터 베이스 설계 순서 : **개념적 설계 → 논리적 설계 → 물리적 설계** 순으로 진행된다.
	- 개념적 설계 : E-R 다이어그램 작성 (DBMS 독립적)
	- 논리적 설계 : 목표 DBMS에 맞는 스키마 설계, 정규화 수행, 트랜잭션 인터페이스 설계(데이터 모델링)
	- 물리적 설계 : 저장 구조 및 접근 경로 설정

##### 49. 정규화

![[Pasted image 20260117142151.png]]
- **제 1 정규형** : 테이블의 모든 컬럼이 **원자값(Atomic Value)** 하나만 가지도록 중복 그룹을 제거
- **제 2 정규형** : 기본키의 일부에만 의존하는 **부분 함수 종속**을 제거(완전 함수 종속)한 상태
- **제 3 정규형** : 기본키가 아닌 속성들 간의 종속인 **이행 함수 종속**을 제거한 상태
- BCNF : 모든 결정자가 후보키가 되도록 강제하여 후보키가 아닌 결정자를 제거한 상태
- 제 4 정규형 : 두 개 이상의 다치 종속을 제거한 상태
- 제 5 정규형 : 조인 종속이 후보키를 통해서만 성립하도록 한 상태

#####  50. 개체-관계 모델 (E-R모델)
![[Pasted image 20260117142128.png]]
- 개체는 사각형
- 속성은 타원
- 관계는 마름모

##### 51. 관계형 데이터베이스 구성 요소
![[Pasted image 20260117142343.png]]
- 한 테이블 내에는 동일한 이름의 컬럼이 있을 수 없다.


#####  53. 디비 키의 종류
![[Pasted image 20260117142502.png]]
- **후보키** : 튜플을 유일하게 식별할 수 있는 속성들의 집합으로 유일성과 최소성을 모두 만족해야한다.
- **대체키** :  후보키 중에서 기본키로 선택되지 않은 나머지 키를 의미한다.
- **슈퍼키** : 유일성은 만족하지만 최소성은 만족하지 않아도 되는 키.
- **외래키** : 다른 테이블의 기본키를 참조하여 관계를 맺는 속성

##### 55. 데이터베이스 병행제어
![[Pasted image 20260117142956.png]]
- 병행제어
	- 다중 사용자 환경에서 동시에 접근을 허용하기 위함
	- 데이터의 일관성(정확성)을 위해 잠금(Locking) 등의 제어가 필수적이다.
	- (이미지 마킹) 로킹 단위가 크면 한 번에 하나의 사용자만 큰 데이터를 점유하므로, 다른 사용자가 기다려야해서 병행성 수준이 낮아진다.
	- 로킹단위가 크면(테이블 전체를 잠금) 관리해야할 로크의 개수가 줄어들기 때문에 제어 기법은 **단순해진다.**
 
##### 56. 시스템 카탈로그
![[Pasted image 20260117143007.png]]
- 시스템 카탈로그
	- 시스템 객체 정보를 담고있는 시스템 데이터베이스다.
	- 데이터에 대한 데이터라는 의미로 데이터 사전(Data Dicitonary) 라고도 부른다.
	- 테이블, 뷰, 인덱스, 접근권한 등 메타데이터를 저장한다.
	- 일반 사용자도 SELECT 문을 통해서 시스템 카탈로그의 내용을 조회할 수 있다. 다만 사용자가 직접 내용을 수정할 수는 없으며 이는 시스템(DBMS)이 관리한다.

##### 57. 트리거
![[Pasted image 20260117143103.png]]
- 트리거
	- **이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL**
	- 트리거는 데이터의 삽입, 갱신, 삭제와 같은 특정 이벤트가 발생했을 때, DBMS가 자동으로 실행하도록 정의된 절차적 코드다.

- 최적의 경로를 찾아주는 모듈은 옵티마이저
- 호출을 통해서 실행되는 것은 저장 프로시저에 가까움. 트리거는 명시적으로 호출하지 않고 자동으로 실행

##### 58. 관계대수와 관계해석
![[Pasted image 20260117143131.png]]
- 관계대수
	- 절차적 언어, How
	- 원하는 데이터를 얻기위해 어떤 순서로 연산을 수행해야하는지 과정을 명시한다.
	- SQL의 내부 처리 과정(실행계획)의 기초가 된다.
	- "이 테이블을 가져와서 → 자르고(Select) → 필요한 것만 남기고(Project) → 합쳐라(Join)"라고 단계별로 지시하는 방식
- 관계해석
	- 비절차적 언어, What, 프레디킷(Predicate) 해석
	- 구하는 절차(순서)는 중요하지 않고, **원하는 데이터가 무엇인지(조건)** 만 정의한다.
	- SQL 문법 설계의 이론적 기초
	- "나는 스테이크를 원해(What)"라고 주문하는 것


##### 59. 정보시스템 
![[Pasted image 20260117143209.png]]
- 고가용성 솔루션
	- 서버가 고장나더라도 서비스가 멈추지 않게하는 기술
	- 여러대의 서버를 1개의 클러스터로 묶어서 운영
- 점대점 연결방식
	- 네트워크 두개의 장치를 1대1로 직접 연결하는 단순한 통신형태
	- 전용회선사용, 보안이 우수하고 속도가 안정적, 하지만 연결이 많아지면 설치 비용이 비싸짐
- 스턱스넷
	- 산업 시설을 파괴하기위해 특수제작된 **악성코드(웜 바이러스)**
	- 국가 기반시설 (SCADA 시스템)을 목표로 공격한다.
- 루팅
	- 안드로이드 운영체제에서 모바일 기기의 최고 관리자 권한(Root)을 획득하는 행위

##### 60. 디비 트렌젝션 분석
![[Pasted image 20260117143240.png]]
- CRUD 분석
	- 데이터가 제대로 관리되고 있는지 검증하는 과정
	- 우리가 만든 프로그램이 CRUD 기능을 빠짐없이 다 갖췄나를 표를 그려서 확인하는것

##### 61. OSI 7계층
![[Pasted image 20260117143306.png]]
- OSI 7계층
	- **1계층 : Physical Layer (물리 계층)**
		- 핵심역할: 데이터를 전기 신호(0과 1의 비트)로 변환하여 케이블로 전송한다.
		- 주요장비 : 케이블, 리피터, 허브
		- 전송단위 : 비트
	- **2계층 : Data Link Layer (데이터 링크 계층)**
		- 핵심역할: 인접한 두 장비(Hop to Hop) 간의 신뢰성 있는 정보 전송을 담당. 오류를 검출, 흐름을 제어한다.
		- ==*MAC 주소, 오류 제어 , 흐름 제어*
		- 주요장비 : 브리지, 스위치
		- 전송단위 : 프레임
	- **3계층 : Network Layer (네트워크 계층)**
		- 핵심역할:  목적지까지 가장 안전하고 빠른 길을 찾아주는 라우팅(경로설정)을 담당
		- ==IP 주소, 라우팅, 경로설정
		- 주요장비 : 라우터, L3 스위치
		- 전송단위 : 패킷
	- **4계층:  Transport Layer (전송 계층)**
		- 핵심역할 : End to End의 사용자들이 신뢰성 있게 데이터를 주고받을 수 있도록함. 데이터가 제대로 도착했는지 확인
		- ==TCP/UDP, 오류수정, 흐름제어, 혼잡제어, 포트 번호
		- 전송단위 : 세그먼트
	- **5계층: Session Layer (세션계층)**
		- 핵심역할: 통신하는 두 응용 프로그램간의 대화(Session)를 관리한다. (연결생성, 유지, 종료)
		- ==동기화, 대화제어, 토큰(Token)
	- **6계층: Presentation Layer (표현계층)**
		- 핵심역할 : 데이터의 형식(Format)을 변환한다. 서로 다른 시스템끼리 데이터를 이해할 수 있게 번역한다.
		- ==암호화, 압축, 코드 변환(ASCII, JPEG 등)
	- **7계층: Application Layer (응용계층)**
		- 사용자가 네트워크에 접근할 수 있도록 인터페이스를 제공한다. 우리가 쓰는 프로그램들이 여기서 동작한다.
		- ==HTTP(웹), FTP(파일), SMTP(이메일), Telnet
		- 전송단위: 데이터

##### 65. 파이썬 코드
![[Pasted image 20260117143553.png]]

##### 66. HRN
![[Pasted image 20260117143621.png]]
- HRN 스케줄링 방식
	- 응답률이 가장 높은 것을 먼저 처리하는 방식
	- 즉, 우선순위 계산식 값이 클 수록 우선순위가 높다. (응답률이 높을수록 높음)
	- 대기시간과 서비스 시간을 모두 고려함
	- 대기시간이 길어지면 우선순위 값이 커진다.
	- SJF 기법은 실행 시간이 긴 프로세스가 하염없이 기다리는 Starvation이 발생하는데 이를 보완하기 위해서 대기시간을 점수에 반영한다.
	- **우선순위 = (대기시간 + 서비스시간) / 서비스 시간 ** 

##### 67. malloc
![[Pasted image 20260117143700.png]]
- malloc
	- 프로그램 실행 중에 필요한 만큼 힙 영역에 메모리를 빌리는 것
	- malloc : 메모리 할당 (Memory Allocation)
	- free : 빌린 메모리 반납 (해제하지 않으면 메모리 누수 발생)
	- 실패시 NULL 포인터 반환하므로 예외처리가 필요하다.
	- 바이트 단위.

##### 68. 프로세스
![[Pasted image 20260117143726.png]]
- 프로세스
	- 프로세스 : 실행 중인 프로그램 그 자체, 자원을 할당받는 주체
	- PCB (Process Control Block) : 운영체제가 프로세스를 관리하기 위해 만드는 프로세스 명찰


##### 70. 쓰레싱
![[Pasted image 20260117143838.png]]
- 스레싱 
	- 메모리에 너무 많은 프로세스가 올라오면, CPU가 일을 하는 시간보다 필요한 페이지를 메모리에 올리고 내리는 (페이지 교체)데 시간을 다 써버려서 **시스템 성능이 급격히 떨어지는 현상**을 말한다.
- Page Fault
	- 찾는 데이터가 메모리에 없는 상황. 너무 자주 발생하면 스레싱으로 이어진다
- 워킹셋
	- 스래싱을 방지하기 위한 해결책 중 하나로, 프로세스가 자주 참조하는 페이지들의 집합을 미리 메모리에 올려두는 기법.

##### 71. IP 버전
![[Pasted image 20260117143855.png]]
- IPv4 : 32비트 주소, 8비트씩 4부분(옥텟), 점으로 구분한다. (192.168.0.1) 
- IPv6 : 128비트 주소, 16비트씩 8부분, 콜론으로 구분 (2001:0db8:85a3:0000:0000:8a2e:0370:7334)
	- 네비트당 한자리, 한 부분당 16비트
	- IPv6는 IPv4의 주소 부족 문제를 해결하기 위해 나왔지만, 동시에 **헤더 구조를 단순화**하고 불필요한 필드를 제거하여 **패킷 처리 속도를 향상** 시켰다. 또안 보안과 품질 보장(QoS) 기능이 강화되었다. 

##### 74. 교착상태 Race Condition
![[Pasted image 20260117143931.png]]
- Mutual Exclusion : 자원은 한번에 한명만 사용할 수 있다.
- Hold and Wait : 자원을 가진 상태에서 다른 자원을 얻기위해 대기해야한다.
- Non-Preemption : 자원을 강제로 가져갈 수 없다.
- Circular Wait : 자원을 기다리는 프로세스들이 서로 꼬리 물기를 한다.

##### 75. MAC 방식
![[Pasted image 20260117143946.png]]
- IEEE 802.3은 유선 인터넷(이더넷)의 표준 규격
- CSMA/CD (Carrier Sense Multiple Access with Collision Detection)
	- 회선이 비었나 확인하고(Sense)
	- 비었으면 보내는데 (Access)
	- 만약 다른 애랑 동시에 보내서 충돌(Collision)이 나면 잠시 멈췄다가(Detection) 다시 보내는 방식
- Token Bus : IEEE 802.4 표준
- Token Ring : IEEE 802.5 표준

##### 76. 프로세스 상태 종류
![[Pasted image 20260117144001.png]]

##### 77. TCP에서 사용하는 논리주소를 물리주소로 변환시켜주는 프로토콜
![[Pasted image 20260117144017.png]]
- ARP
	- Address Resolution Protocol
	- IP주소는 아는데 MAC이 뭐야? 라고 물어보는 프로토콜
	- RARP는 반대 (MAC에서 IP)
- FTP : 파일을 주고받는 프로토콜
- TCP : 데이터를 안정적으로 전송하는 전송 계층 프로토콜
- IP : 주소를 지정하고 경로를 찾는 네트워크 계층 프로토콜

##### 78. 네트워크 계층
![[Pasted image 20260117144050.png]]
- 노드에서 인접한 다른 노드로 프레임을 전송하는 것은 2계층 데이터 링크 레이어 (합투합)

- 네트워크 레이어
	- 라우팅 (경로 지정) 기능을 수행
	- 헤더에 IP 주소(논리주소)를 붙임
	- 최종 목적지 까지 전달 (End to End)

##### 79. 프레임워크
![[Pasted image 20260117144117.png]]
- 프레임워크
	- 프레임워크는 개발을 편하게 하기 위해 만들어준 **반제품** 상태의 뼈대 코드
	- 기본 골격과 필수 기능이 미리 구현되어있어 개발자는 비즈니스 로직만 채워넣으면 된다.
	- 확장성은 프레임워크의 장점 중 하나
	- 아키텍처 설계는 설계 도면이고 프레임워크는 그 도면대로 지어놓은 실제 구조물
	- 모듈화가 잘되어있어 유지보수가 쉽다.

##### 80. stdlib.h
![[Pasted image 20260117144152.png]]
- stdlib.h
	- stdlib.h는 C언어의 일반적인 유틸리티 함수들을 모아놓은 헤더 파일
	- 문자열과 숫자 변환 함수, 동적메모리 할당, 난수 생성, 프로그램 종료 등이 포함된다.
- strlen과 같은 문자열 처리 함수는 string.h에 있다.
- 표준 입출력(printf, scanf)은 stdio.h이다.
- 삼각함수, 제곱근 등은 math.h에 있다.

##### 81. 입력 데이터 검증 및 표현
![[Pasted image 20260117144234.png]]
- 공격 기법의 명칭, 그 공격에 대한 설명
	- SQL 삽입(injection) : 웹 입력창에 SQL 구문을 집어넣어 DB 정보를 빼내는 공격
	- 크로스사이트 스크립트 (XSS) : 게시판 등에 악성 자바스크립트를 심어서, 이 글을 읽는 **다른 사용자 (방문자)** 의 쿠기나 정보를 훔치는 공격 
	- 운영체제 명령어 삽입 : 웹 입력값을 통해 시스템 내부 명령어 (cmd, sh 등)를 실행시키는 공격

- 위험한 형식 파일 업로드 (Unrestricted File Upload) : 악의적인 명령어가 포함된 스크립트 파일을 업로드함으로써 시스템에 손상을 줌
- 자원 삽입 (Resource Injection) : 공격자가 내부 시스템의 파일 경로, 포트 번호 등 **식별자(Resource Identifier)** 를 조작하여 접근 권한이 없는 시스템 자원을 사용하거나 수정하는 공격을 말한다.

##### 82. 악석코드 자가복제 (worm)
![[Pasted image 20260117144254.png]]
- Worm
	- 숙주 파일(기생파일)이 필요없다. 자기 자신이 독립적인 프로그램이며, 네트워크를 타고 스스로 복제하여 퍼져나간다.
	- 바이러스는 반드시 엑셀, 한글 파일 같은 숙주 파일에 붙어서 이동해야한다.

- Rogue Ware 로그웨어 : 바이서르 치료해줄게 돈 내놔 라고 협박하는 가짜 백신 프로그램
- Adware 애드웨어 : 광고를 띄우는 것이 목적인 프로그램
- Reflection Attack (반사 공격) : 서버의 응답을 이용하는 네트워크 공격 기법(DDos의 일종)

##### 83. 정보보안 요소 중 무결성 
![[Pasted image 20260117144354.png]]
- 핵심개념
	- 보안 3요소 CIA
		1. Confidentiality (기밀성)
			- 허락된 사람만 봐야(Read)한다. 비밀보장
		2. Integrity (무결성)
			- 허락된 사람만 고쳐야(Modify / Write) 한다. 위/변조 방지
		3. Availability (가용성)
			- 필요할 때 언제든 쓸 수 있어야한다. 서비스 중단 방지

- 인가된 사람한테만 접근 : 기밀성
- 사요자가 합법적인지 확인 : 인증
- 언제라도 사용할 수 있어야한다 : 가용성
- 인가된 사용자만 수정할 수 있음 : 무결성

##### 84. 세션 하이재킹
![[Pasted image 20260117144403.png]]
- 세션 하이재킹
	- 이미 로그인된(연결된) 두 컴퓨터 사이의 Session 을 가로채서 공격자가 로그인한 척 끼어드는 공격
- 탐지 원리
	- 공격자가 끼어들면 원래 통신하던 Client와 Server 사이의 Sequence Number가 꼬이게 된다.
	- 엉뚱한 번호를 받으면 재전송 요청(ACK)을 무한 반복하게 되는데 이를 **ACK Storm** 이라고 한다.
- FTP SYN SEGMENT
	- 특정 포트(FTP)에 접속 요청을 보내는 것을 말한다. 이는 포트 스캔이나 단순 접속 시도다.




##### 87. COCOMO 모델
![[Pasted image 20260117144511.png]]
- COCOMO
	- 보헴이 제안.
	- 코드라인수 (LOC lines of code)를 기반으로 비용을 산정하는 방식이다. (고전적)
	- 소프트웨어 복잡도에 따라 세가지 유형으로 나뉜다.
		1. Organic (단순형) : 5만 라인 이하. 사무 처리용, 업무용 처럼 비교적 간단한 소프트웨어
		2. Semi-Detached (반분리형) : 30만 라인 이하. 운영체제(OS)나 데이터베이스 관리 시스템(DBMS) 처럼 다소 복잡한 소프트웨어
		3. Embeded (내장형) : 30만 라인 이상. 미사일 유도 시스템, 신호 제어 시스템처럼 하드웨어와 밀접하게 연관된 초대형 / 고난도 소프트웨어
- UFP는 기능 점수(Function Point) 모형에서 사용하는 용어

##### 88. Wi-Fi
![[Pasted image 20260117144519.png]]
WPA
- 초기 무선랜 표준이었던 WEP의 보안취약점이 발견되면서 이를 보완하기 위해 Wi-Fi 얼라이언스에서 제정한 보안 표준.
- 데이터 암호화를 강화하기 위해 **TKIP(Temporal Key Integrity Protocol)** 등을 사용
- 이후 더 강력한 WPA2(AES 사용), WPA3 등으로 발전함

##### 89. AES
![[Pasted image 20260117144537.png]]
- AES
	- 기존의 DES가 키 길이가 짧아 해킹에 취약해지자 NIST에서 선택한 차세대 표준 알고리즘
	- 28/192/256비트의 키 길이를 지원하는 **블록 암호화** 방식

#####  90. 침입 탐지 시스템 IDS
![[Pasted image 20260117144611.png]]
- IDS
	- 방화벽(Firewall)이 막지 못하고 들어온 패킷이나 시스템 내부의 수상한 움직임을 감시하고 경보를 울리는 시스템 (차단기능까지 포함하면 IPS)

| 구분  | 오용 탐지 (Misuse Detection)                   | 이상 탐지 (Anomaly Detection)               |
| --- | ------------------------------------------ | --------------------------------------- |
| 별명  | Signature Base (서명 기반), Knowledge Base     | Behavior Base (행위 기반), Statistical Base |
| 원리  | 미리 등록된 공격 패턴(Signature)과 일치하면 탐지           | 평소의 정상적인 패턴을 학습해두고, 벗어나면 탐지             |
| 장점  | 알려진 공격은 100% 탐지 가능, 오탐(False Positive)이 낮음 | 새로운 공격(Zero-Day Attack) 탐지 가능           |
| 단점  | 새로운 공격(신규 패턴)은 탐지 불가                       | 정상 행위도 공격으로 오해할 확률(오탐)이 높음              |
- HIDS
	- 컴퓨터 내부에 설치
	- 윈도우 / 리눅스 로그 파일 감시, 중요 시스템 파일이 변경(무결성)되었는지 확인
- NIDS
	- 라우터나 스위치에 설치
	- 지나가는 패킷의 내용을뜯어보고 감시 (대표적으로 snort)


#####  네트워크 장비
![[Pasted image 20260117144640.png]]
- **리피터 & 허브 - 1계층**
	- 신호 증폭기.
	- 약해진 신호를 다시 보내는 역할
	- 리피터는 입구와 출구가 하나씩 허브는 여러대의 장비가 동시에 연결
- **브리지 (Bridge) & 스위치 (Switch) - 2계층 (데이터 링크 계층)**
	- 필터링, 포워딩
	- 브리지 + 허브 = 스위치
- **라우터 (Router) - 3계층 (네트워크 계층)**
	- 서로다른 네트워크를 연결
	- 목적지까지 가는 길이 여러 갈래일 때 최적 경로를 찾아줌


#####  92. SQL Injection
![[Pasted image 20260117144903.png]]



##### 브리지, 루프, 스패닝트리
![[Pasted image 20260117144924.png]]
- 네트워크를 구성할 때 케이블 하나가 끊어져도 통신이 되도록 스위치나 브리지를 이중, 삼중으로 연결한다. 그런데 이렇게 연결하면 루프가생긴다.
- 데이터(브로드캐스트 패킷)가 목적지로 도착하지 않고 이 루프를 따라 돈다. 이것이 쌓여 브로드캐스트 스톰이 발생해 네트워크 전체가 마비된다.

- Spanning Tree Algorithm
	- 물리적으로 연결되어있지만 논리적으로 끊어버리자
	1. 네트워크상의 모든 브리지/스위치 중에서 대장을 뽑는다.
	2. 대장으로 가는 가장 빠른 길 하나만 남겨둔다.
	3. 나머지 우회로는 소프트웨어적으로 차단한다.
	4. 그러면 전체 구조가 순환 없는 Tree 모양이 된다.
	5. 만약 쓰던 길이 끊어지면? 아까 차단해뒀던 우회로를 다시 연다.

##### 블록체인
![[Pasted image 20260117145002.png]]
- BaaS
	- 블록체인 서비스를 만들려면 노드(컴퓨터)를 수없이 많이 연결하고 합의 알고리즘을 설치하고 보안 설정을 해야 한다. 구축 난이도가 매우 높고 비용도 많이 든다.
	- 아마존(AWS), MS(Azure), IBM 같은 클라우드 제공사가 블록체인 인프라를 다 만들어 놓을 테니 너희는 들어와서 기능만 빌려 쓰라고 제공하는 서비스

#####  소프트웨어 재공학
![[Pasted image 20260117145024.png]]
- 이식 : 기존 소프트웨어를 완전히 다른 환경으로 옮기는 행위
- 분석 : 기존 시스템이 어떻게 돌아가는지 파악하는 단계.
- 역공학 : 완성된 코드를 거꾸로 분석해서 설계도나 논리를 알아내는 것. (완성품 -> 설계도)
- 재구성 : 기능은 안 바꾸고 내부의 지저분한 코드만 깔끔하게 정리하는 것. (리팩토링과 유사)


##### 암호화 알고리즘 분류
![[Pasted image 20260117145041.png]]
- 복호화 가능 vs 불가능

1. 해시함수
	- one way
	- 어떤데이터를 넣어도 고정된 길이의 난수로 바꿈
	- 복호화가 불가능하다. 결과값만 보고 원래 내용을 알아낼 수 없다.
	- MD4, MD5, SHA-1, SHA-256
2. 대칭키 / 비대칭키 암호화
	- 양방향
	- 키를 사용해서 데이터를 잠금
	- 키가 있으면 다시 원래대로 풀 수 있다.
	- AES, DES, SEED, RSA

#####  SAN
![[Pasted image 20260117145110.png]]
- SAN
	- 예전에는 서버 뒤에 하드디스크를 직접 꽂았다(DAN). 그런데 서버가 여러 대가 되고 데이터가 폭증하니 저장장치만 따로 모아서 관리하고 싶다는 니즈가 생겼다. 그런데 일반 네트워크(LAN)로 데이터를 보내자니 유튜브 보고 메일 보내는 트래픽이랑 섞여서 너무 느리게됨.
	- 해결책
		- 일반 네트워크(LAN)와는 완전히 분리된 오직 데이터 저장만을 위한 별도의 네트워크를 구축한다.
		- 이때 속도를 극대화하기 위해 일반 구리선 대신 광채널 이라는 매우 빠른 케이블과 스위치를 사용
		- 특징: 서로 다른 OS(윈도우 서버, 리눅스 서버 등)가 있더라도, SAN 스위치를 통해 거대 스토리지를 마치 내 로컬 하드처럼 공유해서 쓸 수 있다.
DAS (Direct Attached Storage): PC에 외장하드 꽂듯이 서버에 직접 연결하는 방식
NAS (Network Attached Storage): 일반 인터넷 선을 통해 파일을 공유하는 방식.
MBR (Master Boot Record): 하드디스크의 첫 번째 섹터에 있는 부팅 정보 저장 영역

#####  메쉬네트워크
![[Pasted image 20260117145133.png]]
- 와이파이 공유기 하나로는 넓은 곳을 커버하기 힘들다
	- 기존 방식 (Star Topology): 중앙에 공유기(AP)가 하나 있고, 모든 스마트폰이 여기에만 연결됩니다. 공유기에서 멀어지면 인터넷이 끊긴다.
- 메쉬방식
	- 네트워크에 참여하는 모든 기기(노드)가 서로서로 연결되어 **중계기 역할**
	- 커버리지 확장: A가 B에게, B가 C에게 신호를 전달해주므로 인터넷 범위를 무한히 넓힐 수 있습니다. 
	- 안정성: 중간에 기기 하나가 고장 나도, 옆에 있는 다른 기기를 통해 우회해서 통신하면 되므로 네트워크가 죽지 않는다.


##### 프로젝트 관리 도구
![[Pasted image 20260117145217.png]]
CPM(네트워크 그림)과 간트 차트(막대 그래프)

- CPM
	- 동그라미(노드)와 화살표(간선)로 이루어진 네트워크 도표
	- 이 프로젝트를 끝내는 데 최소 며칠이 걸릴까?"를 계산하는 것
	- 작업 A가 끝나야 B를 할 수 있다는 식의 **선후 관계**를 따짐
	- 시작부터 끝까지 가는 경로 중 가장 시간이 오래 걸리는 경로(임계 경로)를 찾는다.

막대그래프는 간트차트

##### HSM
![[Pasted image 20260117145234.png]]

- HSM
	- **정의:** 암호화 키(Key)를 생성하고, 저장하고, 처리하는 **물리적인 전용 장비**
	- HSM은 **Tamper-resistant(조작 방지)** 설계가 되어 있어서, 누군가 강제로 기계를 뜯거나 해킹을 시도하면 저장된 키를 스스로 파괴(Self-destruct) 해버림. 
	- 개념: 아마존(AWS)이나 구글 같은 클라우드 제공사가 데이터 센터에 진짜 물리적인 HSM 장비를 수백 대 설치해 놓습니다. 그리고 사용자에게는 그 장비의 사용 권한만 빌려주는 것
