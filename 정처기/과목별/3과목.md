
## 1. 데이터 모델 및 구조

#### 데이터 모델의 3요소
데이터 모델을 정의할 때 반드시 포함되어야하는 세 가지 구성 요소

- **구조 (Structure)**
	- 데이터베이스에 표현될 대상들의 **정적인 성질**. 개체 간의 관계나 데이터의 구조를 정의
- **연산 (Operation)**
	- 데이터베이스에 저장된 실제 데이터를 처리하는 **작업 명세** 데이터를 어떻게 조작할 것인지에 대한 동적 성질을 정의
- **제약 조건 (Constraint)**
	- 데이터베이스에 저장될 수 있는 길제 데이터의 **논리적 제약**. 무결성을 유지하기 위한 규칙

#### 뷰의 특징
1. **가상성**
	- 물리적으로 구현되어잇지 않으며 시스템 카탈로그에 SELECT 문만 저장
2. **독립성**
	- 기본 테이블의 구조가 바뀌어도 뷰를 사용하는 애플리케이션은 영향을 받지 않는 **논리적 독립성**을 제공
3. **보안성**
	- 민감한 정보가 포함된 컬럼을 제외하고 뷰를 생성해 특정 유저에게만 노출함으로써 보안을 강화
4. **편의성**
	- 여러 테이블을 조인해야하는 복잡한 쿼리를 미리 뷰로 만들어 나중에 단순하게 호출해 사용가능

**뷰의 제약사항**
- **인덱스 불가** : 뷰는 실체가 없는 가상 테이블. 자체적인 인덱스를 가질 수 없다.
- **정의 변경 불가** : 뷰의 정의를 직접 수정 할 수 없다. 바꾸고 싶으면 삭제 후 다시 생성
- **갱신 제약** : 일부 뷰는 `insert`, `update`, `delete` 연산에 제약이 따른다.




## 2. 관계 대수 및 연산

#### 관계 대수
관계 대수는 **절차적 언어.** 

순수 관계 연산자
- Select : 릴레이션에서 조건에 맞는 튜플을 선택 (where)
- Project : 릴레이션에서 원하는 속성만 추출 (select)
- Join : 공통 속성을 매개체로 두 개의 릴레이션을 하나로 합침
- Division : 릴레이션 S의 모든 조건을 만족하는 릴레이션 R의 튜플들을 구한다.

일반 집합 연산자
- 합집합 교집합 차집합
- 카티시안 프로덕트

#### Division 연산
릴레이션 S와 R이 있을 때, S가 가진 모든 속성 값을 다 가지고 있는 R의 데이터를 골라내라




## 3. 물리 데이터 저장소 및 설계

#### 파티션 설계
DB 파티셔닝은 대용량 테이블을 작은 단위로 쪼개 성능을 높이는 기술

- **Range**(범위) 파티셔닝 : 날짜나 숫자 등 연속된 범위로 분할
- **Hash**(해시) 파티셔닝 : 해시 함수를 사용해서 데이터를 균등하게 배분
- **List**(리스트) 파티셔닝 : 특정 목록 (서울, 부산) 에 따라 분할
- **Composite**(조합) 파티셔닝 : 위 방식들을 섞어서 사용





## 4. 고급 데이터베이스 개념

#### OLAP (online analystics processing)
데이터웨어하우스에 저장된 대량의 데이터를 사용자가 쉽고 빠르게 추출하고 분석할 수 있도록 해주는 기술
단순 데이터 조회를 넘어 다차원적인 분석을 수행할 때 필수적

- OLAP 의 주요연산
	- Roll-Up : 분석할 항목에 대해 한 단계 상위 수준의 합계 데이터로 요약
	- Drill-Down : Roll-Up 반대
	- Slicing : 다차원 데이터 항목중 한가지 차원을 고정해 데이터를 자름
	- Dicing : 데이터 항목 중 두 개 이상의 차원을 선택해서 더 작은 입방체를 만듬
	- Pivot : 보고서의 행과 열의 위치를 서로 바꿈

#### Recovery
- 즉시 갱신 기법 : 트랜잭션 도중에도 즉시 DB에 반영
- 지연 갱신 기법
- 검사점 기법 : 장애시 모든 로그 분석 X checkpoint 이후의 로그만 확인
- 그림자 페이지 기법 : 로그 기록 x 복사본인 그림자 페이지를 별도로 보관. 장애시 교체





## 오답노트

- **제 1 정규형** : 테이블의 모든 컬럼이 ==**원자값**==(Atomic Value) 하나만 가지도록 중복 그룹을 제거
- **제 2 정규형** : 기본키의 일부에만 의존하는 부분 함수 종속을 제거(==**완전 함수 종속**==)한 상태
- **제 3 정규형** : 기본키가 아닌 속성들 간의 종속인 ==**이행 함수 종속**==을 제거한 상태
- **BCNF** : 모든 ==**결정자**==가 후보키가 되도록 강제하여 후보키가 아닌 결정자를 제거한 상태
- **제 4 정규형** : 두 개 이상의 ==**다치 종속**==을 제거한 상태
- **제 5 정규형** : ==**조인 종속**==이 후보키를 통해서만 성립하도록 한 상태


- **분산 데이터베이스의 목표 : 4대 투명성**
	1. **위치 투명성** : 저장되어있는 ==**물리적 위치**==를 몰라도 접근할 수 있어야한다.
	2. **중복 투명성** : 데이터가 여러곳에 ==**중복 저장**==되어있어도 하나의 데이터처럼 사용해야한다.
	3. **병행 투명성** : 여러 사용자가 ==**동시에 트랜잭션**==을 실행해도 결과에 이상이 없어야한다.
	4. **장애 투명성** : 특정 부분에 장애가 발생해도 ==**전체 시스템은 동작**==해야한다.

- **물리적 설계**
	- 레코드 지중의 분석

- **논리적 설계**
	- 논리적 데이터베이스 구조로 매핑
	- 트랜잭션 인터페이스 설계
	- 스키마의 평가 및 정제

- **반정규화 - 중복 테이블 추가 방법**
	1. 집계 테이블의 추가 : 각 단계별 데이터를 요약 집계 해놓은 별도의 테이블 생성
	2. 진행 테이블의 추가 : 여러 프로세스가 섞인 경우 특정 공정의 진행상태나 중간 결과를 저장하는 테이블 생성
	3. 특정부분만을 포함하는 테이블 추가 : 데이터 양이 너무 많을 때 자주 사용되는 특정 컬럼이나 특정 범위의 레코드만 뽑아서 별도의 테이블로 관리







![[Pasted image 20260205061330.png]]
![[Pasted image 20260205061251.png]]