

## 1. 럼바우 분석 기법
그래픽 표기법 활용하여 소프트웨어 구성요소를 모델링하는 방법
분석 절차는 객체 모델링 → 동적 모델링 → 기능 모델링 순서로 진행된다.

- **객체 모델링**
	- 정보 모델링 이라고도 부른다.
	- 시스템에서 요구하는 객체를 찾고 객체들 간의 관계를 정의, 가장 중요하며 선행되어야 한다.
	- ==객체 다이어그램, 정보 모델링, 정적 구조
- **동적 모델링**
	- 시간의 흐름에 따른 객체 사이의 제어 흐름, 동작 순서 등 동적인 행위를 표현
	- ==상태 다이어그램, 사건 흐름, 동적 행위
- **기능 모델링**
	- 프로세스들의 자료 흐름을 중심으로 처리 과정 표현
	- ==자료 흐름도(DFD), 데이터 변환, 처리 과정.

##### 자료흐름도 (기능모델링에 이용)
- 구조적 분석 기법 : Top Down
- 시간 흐름 제외 : 데이터의 Flow에 집중.
- 버블 차트 : 프로세스를 원으로 표현
- 최하위 프로세스 : Mini Spec 기술

- 자료 흐름은 처리를 거쳐 변환될 때 마다 새로운 이름을 부여한다.
- 어떤 처리가 출력자료를 산출하기 위해서는 반드시 입력자료가 발생해야한다.
- 상위 단계의 처리와 하위자료 흐름도의 자료흐름은 서로 일치되어야 한다.


## 2. UML
소프트웨어 설계를 위한 공용 표준 설계도

UML은 **사물(Things) , 관계(Relationships), 다이어그램(Diagram)** 으로 구성

- 사물
	- Structural (구조 사물), 시스템 정적 요소 표현
	- Behavioral (행동 사물), 시스템 동적 요소 표현
	- Grouping (그룹 사물), 요소들을 그룹으로 묶음 
	- Annotation (주해 사물), 부가적인 설명이나 제약조건 

- 관계
	- Association : 한 클래스가 다른 클래스 기능 사용
	- Aggregation : 부분이 전체에 포함되지만 전체가 사라져도 부분은 소멸하지 않음 (독립적 생명주기) 
	- Composition : 전체가 사라지면 부분도 사라짐 (종속적 생명주기)
	- Generalization : 상속 관계
	- dependency : 매우 짧은 시간동안만 관계를 맺음. 메서드의 파라미터로 전달, 메서드 내부 지역변수로 잠깐 사용하고 버림
	- Realization : 인터페이스에 정의된 추상 메서드를 실제 클래스에서 구현하는 관계

- 다이어그램
	- 정적 다이어그램
		- 클래스
		- 객체
		- 컴포넌트
		- 배치 (Deployment)
		- 복합체 구조 패키지
	- 동적 다이어그램
		- 유스 케이스
		- 시퀀스
		- 커뮤니케이션 
		- 상태
		- 활동

## 3. 명세 기법

- 정형 명세 기법 (정적 명세 기법)
	- 기반 : 수학적 모델, 이산 수학, 논리학.
	- 장점: 표현이 정확하고 간결하며, 명세의 일관성을 검증하기 좋음. 모호함이 거의 없음
	- 단점: 기법을 배우기 어렵고 사용자가 이해하기 힘듬
	-  도구: Z, VDM, Larch 등.
	- ==**핵심 키워드:** 수학적 모델링, 논리적 증명, 일관성 검증.

- 비정형 명세 기법 (동적 명세 기법)
	- 기반: 상태도, 흐름도, 시나리오, 자연어(글)
	- 장점: 사용자와 개발자 간의 의사소통이 쉽고 이해하기 좋음
	- 단점: 자연어로 작성 시 해석의 모호성이 발생할 수 있고, 일관성 검증이 어려움
	- 도구: 자료 흐름도(DFD), 유스케이스, 상태 전이도(STD)
	- ==**핵심 키워드:** 상태 변화, 시나리오 기반, 의사소통 용이.

- 순서
	1. 도출
	2. 분석
	3. 명세
	4. 확인 및 검증

## 4. GoF
디자인 패턴

##### 생성 패턴
- **Abstract Factory** : 구체 클래스 의존 X, 서로 연관된 객체 조합 만드는 인터페이스 제공
- **Builder** : 동일한 생성 절차에서 서로 다른 표현 결과 만들게 함
- **Factory Method** : 객체 생성 서브클래스에서
- **Prototype** : 원본 객체를 복제하여 객체를 생성
- **Singleton** : 인스턴스 오직 하나

##### 구조 패턴
어브컴데 파플프
- **Adapter** : 호환되지 않은 인터페이스를 가진 클래스 함께 동작할 수 있도록 중간에서 변환
- **Bridge** : 구현부에서 추상층을 분리하여 각자 독립적으로 확장
- **Composite** : 단일 객체와 복합 객체를 동일하게 취급
- **Decorator** : 기존 객체를 유지하며 새로운 기능을 씌움
- **Facade** : 복잡한 서브시스템에 대해 단순한 통합 인터페이스를 제공
- **Flyweight** : 가벼운 객체들을 공유
- **Proxy** : 실제 객체에 대한 접근을 제어하거나 기능을 추가하기 위한 대리 객체

 
##### 행위 패턴 
11개 그냥 외우지말자


## 5. 응집도 결합도

응집도
- Concidental
- Logical
- Temporal
- Procedural
- Communication
- Sequential
- Functional

결합도
- Data
- Stamp
- Control
- External
- Common
- Content


## 6. 인터페이스 설계 및 미들웨어

##### 인터페이스 요구사항 검사 기법
- 동료검토 
- 워크스루
- 인스펙션 : 저자를 제외한 다른 전문가들이 검사 지침서에 따라 결함을 찾음
	- 계획 -> 사전교육 -> 준비 -> 인스펙션 회의 -> 수정 -> 후속 조치 -> 종료

##### 미들웨어
- **DB** : 클라이언트와 DB 서버를 연결
- **RPC** (Remote Procedure Call) : 원격 프로시저를 로컬처럼 호출
- **MOM** (Message Oriented) : 비동기 메세지 기반 전달
- **TP Monitor** : 트랜잭션 처리 및 감시
- **ORB** (Object Request Broker) : 객체지향 미들웨어
- **WAS** : 동적 컨텐츠 처리를 위한 서버

##### 시스템 인터페이스 설계
서로 다른 시스템을 어떻게 연결할지에 대한 아키텍처

**EAI**
기업 내 상호 이질적인 플랫폼들을 통합하는 솔루션
- **Point to Point** : 1:1 단순 연결. 변경시 관리 어려움
- **Hub & Spoke** : 중앙 허브를 통해 연결. 확장 및 유지보수 용이
- **Message Bus:** 앱 사이에 미들웨어를 두어 처리. 확장성 좋음.
- **Hybrid:** Hub & Spoke와 Message Bus의 혼합.

## 7. 소프트웨어 생명주기 모델

**폭포수 모델 (Waterfall)**
- 피드백 어려움 (돌아가기 어려움)
- 개발 후반부에야 결과물을 확인할 수 있어 요구사항 변경에 취약

**프로토타입 모델**
- 개발 전 프로토타입을 만들어 사용자에게 보여주는 방식

**나선형 모델 (Spiral)**
- 폭포수, 프로토타입에 위험 분석 기능을 추가한 모델
- 점진적으로 시스템을 완성해 나감
- ==반복

**애자일**
- 변화에 유연하게 대처하는 개발 방식의 총칭입니다. 일정한 주기를 반복하며 프로토타입을 만들어냄
- 스크럼, xP, 칸반

- **XP**
	- 용기, 단순성, 의사소통, 피드백, 존중
	- 짝프로그래밍
	- TDD (Test Driven Development)
	- Whole Team 
	- Continuous Integration
	- Small Release
	- Collective Ownership

## 8. 자료 사전

| 기호  |    의미    |
| :-: | :------: |
|  =  |    정의    |
|  +  | 구성 (and) |
| {}  |    반복    |
| []  |    선택    |
| ()  |  생략 가능   |
| **  |    주석    |


## 9. 코드의 기본 기능

- 식별 Identification : 대상들을 서로 중복되지 않게 구분하는 기능
- 분류 Classification : 동일한 특성을 가진 데이터를 그룹화하는 기능
- 표준화 Standardization : 일정한 기준과 체계에 따라 통일된 형태로 표현하는 기능
- 배열 Arrangement : 의미 있는 순서로 데이터를 나열하는 기능


## 10. CASE
- Computer Aided Software Engineering
- 개발 과정 전체 혹은 일부를 컴퓨터와 전용 소프트웨어 도구를 사용해서 자동화 하는 것
- 1980년대에 처음 등장

- 원천기술
	- 구조적 기법
	- 프로토타이핑
	- 자동프로그래밍
	- 정보저장소
	- 분산처리
- 주요기능
	- 소프트웨어 생명주기의 전단계 연결
	- 다양한 소프트웨어 개발 모형 지원
	- 모델의 모순검사 및 오류 검증
	- 그래픽 지원
	- 자료 흐름도 작성 등



## 오답노트

객체지향 분석 방법론 중 **E-R 다이어그램**을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성되는 것은?
- **Coad와 Yourdon 방법**

코드 설계에서 **일정한 일련번호**를 부여하는 방식의 코드
- **순차 코드**

**검토 회의 전에 요구사항 명세서를 미리 배포**하여 사전 검토한 후 짧은 검토 회의를 통해 오류를 조기에 검출하는데 목적을 두는 요구사항 검토 방법
- **워크스루**

DFD(Data Flow Diagram)에 대한 설명으로 틀린 것은?
- 자료흐름도는 시간의 흐름을 명확히 표현하지 않는다.

소프트웨어의 상위 설계에 속하지 않는 것은?
- 모듈설계는 하위 설계에 속한다. (상위 설계는 아키텍쳐 설계, 인터페이스 정의, 사용자 인터페이스 정의)

**유스케이스 다이어그램**에서 표현할 수 없는것은?
- **연관관계, 포함관계, 확장관계, 일반화 관계**를 표현할 수 있다.

기본 유스케이스 수행 시 특별한 조건을 만족할 때 수행하는 유스케이스는?
- 특별한 조건을 만족할 때 수행할 유스케이스는 <>로 연결하여 표현하는데, 이와 같이 연결되는 관계를 **확장** 관계라고 합니다.

운영체제 분석을 위해 **리눅스에서 버전**을 확인하고자 할 때 사용되는 명령어는?
- **uname**

요구사항 모델링에 활용되지 않는 것은?
- 단계(Phase) 다이어그램
- **에자일, 유스케이스, 시퀀스는 활용**된다.

소프트웨어를 개발하기 위한 비즈니스(업무)를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석해 내는 기법은?
- 객체지향 분석(OOA)은 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스, 이와 연관된 속성과 연산, 그들 간의 관계 등을 정의하여 모델링하는 작업입니다.


공통 모듈에 대한 명세 기법 중 해당 기능에 대해 일관되게 이해되고 한 가지로 해석될 수 있도록 작성하는 원칙
- **독립성**



퀵정렬
- 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬한다.